[
  {
    "objectID": "245_datamanipulation_for_table.html#tidyverse",
    "href": "245_datamanipulation_for_table.html#tidyverse",
    "title": "5  보건학표_1",
    "section": "5.1 tidyverse",
    "text": "5.1 tidyverse\n데이터를 모으는 입장과 데이터를 분석하는 입장은 매우 다릅니다. 데이터를 모을 때는 모으는 연구자의 입장에서 하게되고, 이를 분석하는 연구자에 맞도록 변형하는 과정이 필요합니다. 또한 표를 만들거나 도표를 만드는 과정에서 데이터의 모양을 우리가 원하는 데로 변형할 필요가 있습니다. R에서 이과정을 쉽게 하기 위해 가장 많이 사용되는 것이 tidyverse 입니다. 이를 이용해서 실습해 보겠습니다\n\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif(!require(\"htmlTable\")) install.packages(\"htmlTable\")\nif(!require(\"haven\")) install.packages(\"haven\")\nif(!require(\"DT\")) install.packages(\"DT\")"
  },
  {
    "objectID": "245_datamanipulation_for_table.html#실습-데이터-준비",
    "href": "245_datamanipulation_for_table.html#실습-데이터-준비",
    "title": "5  보건학표_1",
    "section": "5.2 실습 데이터 준비",
    "text": "5.2 실습 데이터 준비\n데이터 표를 만드는 실습은 6차 근로환경조사 자료를 통해 실습할 것입니다.. 자료는 안전보건공단, 근로환경조사 원시자료 사이트 (http://kosha.or.kr/kosha/data/primitiveData.do) 에서 신청할 수 있습니다.. 데이터를 불러오겠습니다. 안전보건공단 홈페이에서 자료를 다운 받는게 원칙입니다. 다만 실습을 빠르게 진행하기 위해서, dspubs.org 페이지에 있는 파일을 이용하겠습니다.   kwcsData6th.rds   자신의 folder에 data 라는 folder가 있는지 확인하십시오. data라는 폴더에 다운로드하고, 불러오도록 하겠습니다.\n\nurl <- \"https://raw.githubusercontent.com/jinhaslab/opendata/main/kwcs/kwcsData6th.rds\"\ndownload.file(url, \"data/tutorKWCS.rds\")\n\n\nkwcs = readRDS(\"data/tutorKWCS.rds\")\n\nunicode chart\n표를 만들다 보면 크다, 작다, 같다 등은 표시가 쉬운 반면, 크거나 같다, 작거나 같다 등은 표시가 어렵습니다. 이 때 사용해야할 것이 unicode 입니다. 보건학에서 필요한 대표적 유니코드는 사실 2개입니다. 크거나 같다, 작거나 같다. 나머지는 키보드에 이미 있으니 이것을 사용하면 됩니다. 추가적인 unicode는 아래의 항목을 통해 살펴 볼수 있습니다.   Unicode Chart \n\ntibble(\n  \"symbole    \" = c(\"\\u2264\", \"\\u2265\", \"\\u00b1\"), \n  \"unicode    \" = c(\"u2264\", \"u2265\", \"u00b1\")\n) %>% \n  #addHtmlTableStyle(css.cell = c(\"width: 100;\",\"width: 100;\")) %>%\n  htmlTable(caption =\"Simple unicode and symbols\")\n\n\n\n\n\nSimple unicode and symbols\n\nsymbole    \nunicode    \n\n\n\n\n1\n≤\nu2264\n\n\n2\n≥\nu2265\n\n\n3\n±\nu00b1\n\n\n\n\n\n다음과 같이 사용할 수 있습니다. 여기사 \\는 “escape character”로 뒤에 오는 것이 문자가 아니라 약솓된 결과를 나타내 달라는 뜻입니다.\n\nprint(\"x \\u2264 10\")\n\n[1] \"x ≤ 10\"\n\n\n그럼 어떻게 문자를 사용할까요? print 명령을 위와 같이 사용하는 것도 좋지만, 변수를 생성하기에는 좋은 방법이 따로 있습니다. 좋은 방법이란 처음에는 어렵지만, 알고나면 엄청난 것들을 말합니다. paste와 sprintf 입니다. 어떤 것이 좋은가요?. 우리의 목표가 데이터 표현을 자동화 하는 것인데, 자동화를 위해서는 구조를 만들고 거기에 값을 대입 시키는 것이 기본입니다. 그러니, sprintf 를 더 자주 사용하게 됩니다. paste는 모두 붙여 주는 것이니, 쉽게 이해될 것이고, sprintf는 `%s` 마다 무언가를 넣어 붙여 주는 방식입니다. paste와 sprintf는 정말 자주 사용되는 함수이니 꼭 익숙해 지시기 바랍니다.\n\nxp1 = paste(\"x\", \"\\u2264\", \"10\")\nxp2 = sprintf(\"x %s 10\", \"\\u2264\")\nxp1\n\n[1] \"x ≤ 10\"\n\nxp2\n\n[1] \"x ≤ 10\"\n\n\n\n데이터 확인\n\n데이터의 변수를 확인하는 방법은 colnames() , names() 또는 head()를 하용하는 것입니다. 약 400개의 변수가 있으므로, 처음부터 10번째까지 \\[1:10\\] 변수를 찾아 보겠습니다.\n\ncolnames(kwcs)[1:10]\n\n [1] \"id\"           \"wt\"           \"area\"         \"hh_num\"       \"hm_01_gender\"\n [6] \"hm_01_year\"   \"hm_01_estat\"  \"hm_01_rel_t\"  \"hm_02_gender\" \"hm_02_year\"  \n\n\n그럼 45번째 변수 부터 50번째 변수까지 찾아 보겠습니다. []안을 채워보세요.\n\ncolnames(kwcs)[     ]\n\n\n\n[1] \"target\"      \"YEAR\"        \"ESTAT\"       \"AGE\"         \"country\"    \n[6] \"country_etc\"\n\n\n연령인 AGE가 있네요, 성별에 대한 AGE도 있습니다. 그럼 이것을 이용해서 실습을 해보겠습니다. 변수를 하나 선택하는 것은 데이터에 $ 표시를 하고 이후에 변수를 넣는 방식입니다. “데이터\\(변수\" 입니다. 10개만 보겠습니다. 숫자 처럼 보이네요, 확인하겠습니다. `class(kwcs\\)AGE)`를 이용해봅니다. numberic 으로 숫자입니다. 숫자여야 평균 표준편차 등의 계산이 가능합니다.\n\nkwcs$AGE[1:10]\n\n [1] 54 64 65 57 38 47 54 35 68 69\n\nclass(kwcs$AGE)\n\n[1] \"numeric\"\n\n\n이번에는 SEX 변수(variable)의 변수값(value)를 살펴 보겠습니다. class 가 무엇일까요? double 또는 interger 라고 나올 텐데요, R에서는 numberic 값에 interger와 double 속성을 사용한다고 생각하시면 됩니다. 다만 label을 붙여 놓아서 알기 쉽게 되어 있네요.\n\nkwcs$TSEX[1:10]\n\n<labelled<double>[10]>\n [1] 2 2 2 2 1 2 2 2 2 2\n\nLabels:\n value label\n     1  남성\n     2  여성\n\nclass(kwcs$TSEX)\n\n[1] \"haven_labelled\" \"vctrs_vctr\"     \"double\"        \n\n\n국적에 대해서도 알아보겠습니다. character 이네요. 한국에서 시행한 조사라, 한국 국적은 빈칸으로, 이외에는 국적을 적었습니다. kwcs$country_etc를 해보면, 대부분 빈칸입니다. 빈칸인 경 ==\"\", 빈칸이 아닌 경우 !=\"\"을 이용해서 어떤 국적이 있는지 살펴 보겠습니다.\n\nclass(kwcs$country_etc)\n\n[1] \"character\"\n\nkwcs$country_etc[kwcs$country_etc != \"\"][1:10]\n\n [1] \"베트남\"   \"중국\"     \"캐나다\"   \"중국\"     \"중국\"     \"중국\"    \n [7] \"중국\"     \"파키스탄\" \"중국\"     \"중국\"    \n\n\n근로자의 지위를 알아 보겠습니다. 근로자 지위는 emp_stat 입니다. 1은 상용근로자, 2는 임시근로자, 3은 일용근로자 입니다.\n\nkwcs$emp_stat \n\n\nkwcs$emp_stat %>% head()\n\n<labelled<double>[6]>\n[1]  1  3  1 NA  1  1\n\nLabels:\n value      label\n     1 상용근로자\n     2 임시근로자\n     3 일용근로자\n\n\n매우 중요한 개념이 나옵니다. 빈칸과 NA 입니다. 모두 값에 대한 정보가 없다는 것입니다. 값에 대한 정보가 없으면 어떻게 해야 할지는 매우 중요한 개념입니다. 우선 여기서는 값에 대한 정보가 없는 것을 제외하고 분석해 보겠습니다. 값에 대한 정보가 없는 데이터는 제거하여, 새로운 데이터를 만들겠습니다. 이때 filter 라는 것을 이용합니다. is.na라는 것은 NA라는 것을 의미하고, 앞에 !는 그 반대를 말합니다.\n\nkwcs %>%\n  filter(!is.na(emp_stat))\n\n# A tibble: 27,908 × 459\n      id    wt area      hh_num hm_01_gender hm_01_year hm_01_estat  hm_01_rel_t\n   <dbl> <dbl> <dbl+lbl>  <dbl> <dbl+lbl>         <dbl> <dbl+lbl>    <dbl+lbl>  \n 1     2 0.137 3 [대구]       1 2 [여성]           1966 1 [임금 근… 0 [응답자 …\n 2     3 0.350 3 [대구]       1 2 [여성]           1956 1 [임금 근… 0 [응답자 …\n 3     6 0.156 7 [울산]       1 2 [여성]           1955 2 [일이 있… 0 [응답자 …\n 4     9 0.168 7 [울산]       1 1 [남성]           1982 1 [임금 근… 0 [응답자 …\n 5    10 0.675 6 [대전]       4 2 [여성]           1973 1 [임금 근… 0 [응답자 …\n 6    18 2.71  6 [대전]       4 1 [남성]           1972 1 [임금 근… 0 [응답자 …\n 7    19 3.83  3 [대구]       5 1 [남성]           1969 1 [임금 근… 3 [부모]  …\n 8    20 2.90  3 [대구]       4 1 [남성]           1960 1 [임금 근… 3 [부모]  …\n 9    22 2.37  3 [대구]       4 1 [남성]           1984 1 [임금 근… 0 [응답자 …\n10    23 2.26  3 [대구]       3 1 [남성]           1964 1 [임금 근… 3 [부모]  …\n# ℹ 27,898 more rows\n# ℹ 451 more variables: hm_02_gender <dbl+lbl>, hm_02_year <dbl>,\n#   hm_02_estat <dbl+lbl>, hm_02_rel_t <dbl+lbl>, hm_03_gender <dbl+lbl>,\n#   hm_03_year <dbl>, hm_03_estat <dbl+lbl>, hm_03_rel_t <dbl+lbl>,\n#   hm_04_gender <dbl+lbl>, hm_04_year <dbl>, hm_04_estat <dbl+lbl>,\n#   hm_04_rel_t <dbl+lbl>, hm_05_gender <dbl+lbl>, hm_05_year <dbl>,\n#   hm_05_estat <dbl+lbl>, hm_05_rel_t <dbl+lbl>, hm_06_gender <dbl+lbl>, …\n\n\n요통에 대한 변수는 heal_prob1 입니다. 이 변수를 확인해 보겠습니다. 1번은 있다, 2번은 업다, 8번은 무응답, 9번은 거절입니다. 이제 빈칸과 NA가 아니더라도 필요없는 정보가 있습니다. 모르거나/무응답했거나, 거절한 사람입니다. 이를 제거해 보겠습니다.\n\nkwcs %>% \n  filter(!is.na(emp_stat)) %>%\n  filter(!is.na(heal_prob1)) %>%\n  filter(heal_prob1 !=8) %>%\n  filter(heal_prob1 !=9)\n\n이번에는 heal_prob1 에 1, 2 인 사람만 포함시켜 보겠습니다. 어떤 것이 더 편한가요?\n\nkwcs %>% \n  filter(!is.na(emp_stat)) %>%\n  filter(!is.na(heal_prob1)) %>%\n  filter(heal_prob1 %in% c(1, 2))\n\n이번에는 sleep1이라는 변수를 살펴 보겠습니다. sleep1이라는 변수는 잠들기 어려운 것이 매일(1), 한주에 여러번 (2), 한달에 여러번(3), 드물게(5), 전혀 없음(5) 의 5점 척도 입니다. 이데 모름과 거절, 그리고 NA 값을 제거해 보겠습니다.\n그리고 dat라는 새로운 data를 만들고 kwcs를 제거 하겠습니다. dat를 이용해서 분석을 해보겠습니다. 지금까지 사용했던, TSEX, AGE, emp_stat, heal_prob1, sleep1 의 변수를 사용하겠습니다.\n\ndat <- kwcs %>% \n  filter(!is.na(emp_stat)) %>%\n  filter(!is.na(heal_prob1)) %>%\n  filter(heal_prob1 %in% c(1, 2)) %>%\n  filter(sleep1 %in% c(1:5)) %>%\n  select(TSEX, AGE, emp_stat, heal_prob1, sleep1, sleep2, sleep3)\n\n\nrm(kwcs)\n\ndat를 살펴보겠습니다.\n\nhead(dat)\n\n# A tibble: 6 × 7\n  TSEX        AGE emp_stat       heal_prob1 sleep1              sleep2   sleep3 \n  <dbl+lbl> <dbl> <dbl+lbl>      <dbl+lbl>  <dbl+lbl>           <dbl+lb> <dbl+l>\n1 2 [여성]     54 1 [상용근로자] 2 [없다]   5 [전혀없음]        5 [전혀… 5 [전…\n2 2 [여성]     64 3 [일용근로자] 2 [없다]   2 [한 주에 여러 번] 2 [한 … 2 [한 …\n3 2 [여성]     65 1 [상용근로자] 2 [없다]   5 [전혀없음]        5 [전혀… 5 [전…\n4 1 [남성]     38 1 [상용근로자] 2 [없다]   5 [전혀없음]        5 [전혀… 5 [전…\n5 2 [여성]     47 1 [상용근로자] 2 [없다]   5 [전혀없음]        4 [드물… 5 [전…\n6 1 [남성]     48 1 [상용근로자] 1 [있다]   5 [전혀없음]        5 [전혀… 5 [전…"
  },
  {
    "objectID": "245_datamanipulation_for_table.html#central-tendency-mean-median-mode",
    "href": "245_datamanipulation_for_table.html#central-tendency-mean-median-mode",
    "title": "5  보건학표_1",
    "section": "5.3 Central Tendency (mean, median, mode)",
    "text": "5.3 Central Tendency (mean, median, mode)\n대표값중 가장 많이 사용하는 것은 mean 과 median 입니다. 이것을 나타내는 표를 만들어 봅시다. 이것의 평균과 표준 편차를 을 구해 보겠습니다.\n\nmean(dat$AGE)\n\n[1] 44.42325\n\nsd(dat$AGE)\n\n[1] 12.25356\n\n\n이번에는 “tidyverse”를 통해 pipe 코드를 짜 보겠습니다. 데이터를 변형하는 것은 다른 시간에 수행하겠지만, 여기서는 select와 filter, mutate, group_by를 사용하겠습니다. kwcs$TSEX 는 kwcs에서 TSEX를 select하라는 것으로 다름과 같이 사용할 수 있습니다.\n\ndat %>% select(AGE) \n\n# A tibble: 27,891 × 1\n     AGE\n   <dbl>\n 1    54\n 2    64\n 3    65\n 4    38\n 5    47\n 6    48\n 7    23\n 8    28\n 9    36\n10    22\n# ℹ 27,881 more rows\n\n\n\n5.3.1 하나씩 반복\n이후 이것을 가지고 나와서 (pull), 이어 받고 (.) 평균을 구해보겠습니다. 이후 이것을 mean 과 sd 라는 변수에 assign 하겠습니다.\n\ndat %>% select(AGE) %>% pull(.) %>% mean(.)\n\n[1] 44.42325\n\ndat %>% select(AGE) %>% pull(.) %>% sd(.)\n\n[1] 12.25356\n\ndat %>% select(AGE) %>% pull(.) %>% mean(.) -> mean\ndat %>% select(AGE) %>% pull(.) %>% sd(.)   -> sd\n\n그럼 표현해 볼까요?\n\nmean\n\n[1] 44.42325\n\nsd\n\n[1] 12.25356\n\npaste(\"평균은 \", mean, \"표준편차는 \", sd)\n\n[1] \"평균은  44.4232548133807 표준편차는  12.2535577069047\"\n\n\n보기 불편하네요, 소숫점 2째 자리까지 표현하겠습니다. round를 이용합니다. 더 자세한것은 구글에게 물어 보세요.\n\nmean <- dat %>% select(AGE) %>% pull(.) %>% mean(.) %>% round(., 2) \nsd   <- dat %>% select(AGE) %>% pull(.) %>% sd(.)   %>% round(., 2)\npaste(\"평균은\", mean, \", 표준편차는\", sd)\n\n[1] \"평균은 44.42 , 표준편차는 12.25\"\n\nsprintf(\"평균은 %s, 표준편차는 %s\", mean, sd)\n\n[1] \"평균은 44.42, 표준편차는 12.25\"\n\n\nunicode를 이용해서 약속된 표현을 사용해 보겠습니다.\n\npaste(mean, \"\\u00b1\", sd)\n\n[1] \"44.42 ± 12.25\"\n\nsprintf(\"%s \\u00b1 %s\", mean, sd)\n\n[1] \"44.42 ± 12.25\"\n\n\nsprintf 에서 %s 대신에 %.2f 를 사용할 텐데요, 어떤지 살펴 봅시다. 네 %2.f 라는 것은 소수 2째 자리까지 살려서 표현하는 방식입니다. %.2f 는 어떨까요? 공부하는 방법입니다. 무언가를 더 해보는 것!\n\nsprintf(\"%.2f \\u00b1 %.2f\", mean, sd)\n\n[1] \"44.42 ± 12.25\"\n\n\n그럼 median 을 구해볼까요? 해보세요. 무언가를 해보는 것!\n\ndat %>% pull(AGE) %>% median(.)\n\n[1] 45\n\ndat %>% pull(AGE) %>% quantile(., c(0.5))\n\n50% \n 45 \n\n\n그럼 quantile을 구해볼까요?\n\ndat %>% pull(AGE) %>% quantile(., c(0.25, 0.5, 0.75)) \n\n25% 50% 75% \n 35  45  54 \n\np50 = dat %>% pull(AGE) %>% quantile(., c(0.50))\np25 = dat %>% pull(AGE) %>% quantile(., c(0.25)) \np75 = dat %>% pull(AGE) %>% quantile(., c(0.75)) \nsprintf(\"%.0f (%.0f-%.0f)\", p50, p25, p75)\n\n[1] \"45 (35-54)\"\n\n\n이것을 남녀를 나누어서 해보겠습니다. filter 명령문을 써보겠습니다. filter(TSEX==1)이라는 것은 TSEX==1 인 남자만을 고르라는 것입니다. 평균은 아래와 같이 구합니다. sd도 구해봅시다.\n\ndat %>% filter(TSEX==1) %>% pull(AGE) %>% mean(.)\n\n[1] 43.65223\n\ndat %>% filter(TSEX==2) %>% pull(AGE) %>% mean(.)\n\n[1] 45.10761\n\n\n\n\n5.3.2 Group_by summary and Table 1\n\nGroup_by\n\n남녀를 나누어서 평균을 구하는 다른 방법을 사용해 봅니다.\n\ndat %>%\n  group_by(TSEX) %>%\n  summarise(avg = mean(AGE), \n            std = sd(AGE))\n\n# A tibble: 2 × 3\n  TSEX        avg   std\n  <dbl+lbl> <dbl> <dbl>\n1 1 [남성]   43.7  12.2\n2 2 [여성]   45.1  12.3\n\n\n동일한 결과가 나오나요. 네 굉장합니다. 남녀를 나누어서 계산했네요. 지금은 2개의 집단을 나누지만, 만약 100개의 집단이라면 filter를 반복하면 어떻게 해야하나요ㅠㅠ. group_by 는 정말 대단한 명령어 입니다. group_by로 코드 파이프 안에서 다음과 같은 결과를 얻었습니다.\n\ndat %>%\n  group_by(TSEX) %>%\n  summarise(avg = mean(AGE), \n            std = sd(AGE)) %>%\n  mutate(smry = sprintf(\"%.2f \\u00b1 %.2f\", avg, std))\n\n# A tibble: 2 × 4\n  TSEX        avg   std smry         \n  <dbl+lbl> <dbl> <dbl> <chr>        \n1 1 [남성]   43.7  12.2 43.65 ± 12.21\n2 2 [여성]   45.1  12.3 45.11 ± 12.25\n\n\n그럼 중간값과 p25-p75를 표현해 봅시다.\n\ndat %>%\n  group_by(TSEX) %>%\n  summarise(avg = mean(AGE), \n            std = sd(AGE), \n            p25 = quantile(AGE, prob=c(0.25)), \n            p50 = quantile(AGE, prob=c(0.50)), \n            p75 = quantile(AGE, prob=c(0.75)), \n            ) %>%\n  mutate(smry1 = sprintf(\"%.1f \\u00b1 %.1f\", avg, std)) %>%\n  mutate(smry2 = sprintf(\"%.0f (%.0f-%.0f)\", p50, p25, p75)) \n\n# A tibble: 2 × 8\n  TSEX        avg   std   p25   p50   p75 smry1       smry2     \n  <dbl+lbl> <dbl> <dbl> <dbl> <dbl> <dbl> <chr>       <chr>     \n1 1 [남성]   43.7  12.2    34    43    53 43.7 ± 12.2 43 (34-53)\n2 2 [여성]   45.1  12.3    35    46    55 45.1 ± 12.3 46 (35-55)\n\n\n이제 필요한 것만 남겨 보겠습니다.\n\ndat %>%\n  group_by(TSEX) %>%\n  summarise(avg = mean(AGE), \n            std = sd(AGE), \n            p25 = quantile(AGE, prob=c(0.25)), \n            p50 = quantile(AGE, prob=c(0.50)), \n            p75 = quantile(AGE, prob=c(0.75)), \n            ) %>%\n  mutate(smry1 = sprintf(\"%.1f \\u00b1 %.1f\", avg, std)) %>%\n  mutate(smry2 = sprintf(\"%.0f (%.0f-%.0f)\", p50, p25, p75)) %>%\n  select(TSEX, smry1, smry2)\n\n# A tibble: 2 × 3\n  TSEX      smry1       smry2     \n  <dbl+lbl> <chr>       <chr>     \n1 1 [남성]  43.7 ± 12.2 43 (34-53)\n2 2 [여성]  45.1 ± 12.3 46 (35-55)\n\n\n이번에는 같은 내용을 수면에 대해서 해보겠습니다. 수면 점수가 높다믄 것은 잠들기 어렵다는 것이 전혀 없음(5점)에 가깝다는 것입니다. 그러니 역의 점수를 만들겠습니다. 1, 2, 3, 4, 5로 기록된 것을 5, 4, 3, 2, 1로 바꾸고 싶은 것입니다. 아래를 이용할 것입니다.\n\nx= 1:5\ny= 6-x\ny\n\n[1] 5 4 3 2 1\n\n\n\ndat %>%\n  mutate(sleep1in = 6-sleep1)\n\n# A tibble: 27,891 × 8\n   TSEX        AGE emp_stat       heal_prob1 sleep1     sleep2  sleep3  sleep1in\n   <dbl+lbl> <dbl> <dbl+lbl>      <dbl+lbl>  <dbl+lbl>  <dbl+l> <dbl+l>    <dbl>\n 1 2 [여성]     54 1 [상용근로자] 2 [없다]   5 [전혀없… 5 [전… 5 [전…        1\n 2 2 [여성]     64 3 [일용근로자] 2 [없다]   2 [한 주… 2 [한 … 2 [한 …        4\n 3 2 [여성]     65 1 [상용근로자] 2 [없다]   5 [전혀없… 5 [전… 5 [전…        1\n 4 1 [남성]     38 1 [상용근로자] 2 [없다]   5 [전혀없… 5 [전… 5 [전…        1\n 5 2 [여성]     47 1 [상용근로자] 2 [없다]   5 [전혀없… 4 [드… 5 [전…        1\n 6 1 [남성]     48 1 [상용근로자] 1 [있다]   5 [전혀없… 5 [전… 5 [전…        1\n 7 1 [남성]     23 2 [임시근로자] 2 [없다]   4 [드물게… 4 [드… 4 [드…        2\n 8 2 [여성]     28 1 [상용근로자] 2 [없다]   4 [드물게… 4 [드… 4 [드…        2\n 9 1 [남성]     36 1 [상용근로자] 2 [없다]   4 [드물게… 4 [드… 4 [드…        2\n10 2 [여성]     22 2 [임시근로자] 2 [없다]   5 [전혀없… 5 [전… 5 [전…        1\n# ℹ 27,881 more rows\n\n\n이번에는 mutate을 이용해 새로운 변수를 생성해 보겠습니다. 변형된 dat는 dat1에 할당합니다.\n\ndat1<-dat %>%\n  mutate(sleep1in = 6-sleep1, \n         sleep2in = 6-sleep2, \n         sleep3in = 6-sleep3 \n         ) %>%\n  mutate(sexgp = case_when(\n    TSEX ==1 ~ \"Men\", \n    TRUE ~ \"Women\"\n  ))\n\n이번에는 sexgp를 group으로 하여 성별, 연령의 대표값을 나나타내 봅시다.\n\ndat1 %>%\n  group_by(sexgp) %>%\n  summarise(\n            avg = mean(AGE), \n            std = sd(AGE), \n            p50 = quantile(AGE, prob=c(0.50)), \n            p25 = quantile(AGE, prob=c(0.25)), \n            p75 = quantile(AGE, prob=c(0.75))\n            ) %>%\n  mutate(smry1= sprintf(\"%.1f \\u00b1 %.1f\", avg, std),\n         smry2= sprintf(\"%.0f (%.0f-%.0f)\", p50, p25, p75)\n         ) %>%\n    select(sexgp,smry1, smry2)\n\n# A tibble: 2 × 3\n  sexgp smry1       smry2     \n  <chr> <chr>       <chr>     \n1 Men   43.7 ± 12.2 43 (34-53)\n2 Women 45.1 ± 12.3 46 (35-55)\n\n\nhtml Table로 만들면 복사해서 붙여 넣기 매우 편리합니다.\n\ndat1 %>%\n  group_by(TSEX) %>%\n  summarise(\n            avg = mean(AGE), \n            std = sd(AGE), \n            p50 = quantile(AGE, prob=c(0.50)), \n            p25 = quantile(AGE, prob=c(0.25)), \n            p75 = quantile(AGE, prob=c(0.75))\n            ) %>%\n  mutate(smry1= sprintf(\"%.1f \\u00b1 %.1f\", avg, std),\n         smry2= sprintf(\"%.0f (%.0f-%.0f)\", p50, p25, p75)\n         ) %>%\n    select(TSEX,smry1, smry2) %>%\n  htmlTable(caption =\"descritive statistics of study population\")\n\n\n\n\n\ndescritive statistics of study population\n\nTSEX\nsmry1\nsmry2\n\n\n\n\n1\n1\n43.7 ± 12.2\n43 (34-53)\n\n\n2\n2\n45.1 ± 12.3\n46 (35-55)\n\n\n\n\n\n그렇다면, sleep1 에 대해서도 만들어 보십시오.\n연령과 sleep1 에 대한 대표값을 함께 볼 수 있을까요? 지금까지 배운 방법으로 해보도록 하겠습니다.\n\ntab1 = dat1 %>%\n  group_by(TSEX) %>%\n  summarise(\n            avg = mean(AGE), \n            std = sd(AGE), \n            p50 = quantile(AGE, prob=c(0.50)), \n            p25 = quantile(AGE, prob=c(0.25)), \n            p75 = quantile(AGE, prob=c(0.75))\n            ) %>%\n  mutate(smry1= sprintf(\"%.1f \\u00b1 %.1f\", avg, std),\n         smry2= sprintf(\"%.0f (%.0f-%.0f)\", p50, p25, p75)\n         ) %>%\n    select(TSEX,smry1, smry2) %>%\n  mutate(variable = \"AGE\")\n\n\ntab2 = dat1 %>%\n  group_by(TSEX) %>%\n  summarise(\n            avg = mean(sleep1), \n            std = sd(sleep1), \n            p50 = quantile(sleep1, prob=c(0.50)), \n            p25 = quantile(sleep1, prob=c(0.25)), \n            p75 = quantile(sleep1, prob=c(0.75))\n            ) %>%\n  mutate(smry1= sprintf(\"%.1f \\u00b1 %.1f\", avg, std),\n         smry2= sprintf(\"%.0f (%.0f-%.0f)\", p50, p25, p75)\n         ) %>%\n    select(TSEX,smry1, smry2) %>%\n  mutate(variable = \"sleep1\")\n\n이 둘을 합쳐 보겠습니다.\n\nrbind(tab1, tab2)\n\n# A tibble: 4 × 4\n  TSEX      smry1       smry2      variable\n  <dbl+lbl> <chr>       <chr>      <chr>   \n1 1 [남성]  43.7 ± 12.2 43 (34-53) AGE     \n2 2 [여성]  45.1 ± 12.3 46 (35-55) AGE     \n3 1 [남성]  4.5 ± 0.7   5 (4-5)    sleep1  \n4 2 [여성]  4.4 ± 0.8   5 (4-5)    sleep1  \n\n\nsleep1까지 했는데요, sleep2, sleep3 까지 하려면 어떻게 해야 하나요? 이것을 2번더 반복해야 합니다. 만약에 변수가 100개라면 어떻게 해야할까요, 네 1000번 하면됩니다. 좀 익숙한 표를 만들기 위해서 반복하는 것이 가장 기본이 됩니다. 그래도 이제는 이 방법을 응용해서, 컴퓨터가 쉽게 작동하는 방식으로 생각해 보겠습니다.\n\n\n5.3.3 Long File and Table 1\n\nlong file\n\n이제 group 대신에 group이 될 파일을 선택해서 long file로 만들어 보겠습니다. 원하는 파일만 골라 봅니다. 성에 따른 연령, sleep1, 2, 3를 정리해 보겠습니다.\n\ndat1 %>% select(sexgp, AGE, sleep1in, sleep2in, sleep3in)\n\n# A tibble: 27,891 × 5\n   sexgp   AGE sleep1in sleep2in sleep3in\n   <chr> <dbl>    <dbl>    <dbl>    <dbl>\n 1 Women    54        1        1        1\n 2 Women    64        4        4        4\n 3 Women    65        1        1        1\n 4 Men      38        1        1        1\n 5 Women    47        1        2        1\n 6 Men      48        1        1        1\n 7 Men      23        2        2        2\n 8 Women    28        2        2        2\n 9 Men      36        2        2        2\n10 Women    22        1        1        1\n# ℹ 27,881 more rows\n\n\n이러한 파일을 wide라고 부릅니다. 이제 우리는 TSEX별, AGE와 Sleep1의 값을 얻고자 합니다. 그러면 TSEX와 AGE, TSEX와 Sleep이 하나의 group이 됩니다. group을 반복한것과 같습니다. 즉 group의 기본은 -로 제외하고, 이와 상관되는 변수는 모두 포함하여 variables라는 이름으로 만들고, 값은 values라는 변수로 변환시키는 것입니다.\n\ndat1 %>% select(sexgp, AGE, sleep1in, sleep2in, sleep3in) %>%\n  pivot_longer(-c(sexgp), names_to =\"variables\", values_to = \"values\")\n\n# A tibble: 111,564 × 3\n   sexgp variables values\n   <chr> <chr>      <dbl>\n 1 Women AGE           54\n 2 Women sleep1in       1\n 3 Women sleep2in       1\n 4 Women sleep3in       1\n 5 Women AGE           64\n 6 Women sleep1in       4\n 7 Women sleep2in       4\n 8 Women sleep3in       4\n 9 Women AGE           65\n10 Women sleep1in       1\n# ℹ 111,554 more rows\n\n\n평균에 대해서만 먼저 해보겠습니다.\n\ndat1%>% select(sexgp, AGE, sleep1, sleep2, sleep3) %>%\n  pivot_longer(-c(sexgp), names_to =\"variables\", values_to = \"values\") %>%\n  group_by(sexgp, variables) %>%\n  summarise(avg = mean(values, na.rm =TRUE), \n            std = sd(values, na.rm =TRUE), \n            p50 = quantile(values, prob = 0.50, na.rm =TRUE),\n            p25 = quantile(values, prob = 0.25, na.rm =TRUE), \n            p75 = quantile(values, prob = 0.75, na.rm =TRUE) \n            ) %>%\n  mutate(mean_std  = sprintf(\"%.1f\\u00b1%.1f\", avg, std), \n         median_IQR= sprintf(\"%.0f (%.0f-%.0f)\", p50, p25, p75)) %>%\n  select(sexgp, variables, mean_std)\n\n# A tibble: 8 × 3\n# Groups:   sexgp [2]\n  sexgp variables mean_std \n  <chr> <chr>     <chr>    \n1 Men   AGE       43.7±12.2\n2 Men   sleep1    4.5±0.7  \n3 Men   sleep2    4.5±0.8  \n4 Men   sleep3    4.3±0.9  \n5 Women AGE       45.1±12.3\n6 Women sleep1    4.4±0.8  \n7 Women sleep2    4.4±0.9  \n8 Women sleep3    4.2±0.9  \n\n\n무언가 복잡하지만 쉬워졌죠? 이말에 고개를 끄덕이셨다면 여러분은 이제 R coding에 빠져 들고 있는 것입니다. \n이제 이것을 사람이 보기 편한 상태인 wide로 바꾸겠습니다. pivot_wider를 사용하고 우리가 원하는 가로로 필요한 정보를 names로 하고 원하는 값을 values로 하겠습니다. 이것을 tab1으로 정의하겠습니다.\n\ndat1 %>% select(sexgp, AGE, sleep1, sleep2, sleep3) %>%\n  pivot_longer(-c(sexgp), names_to =\"variables\", values_to = \"values\") %>%\n  group_by(sexgp, variables) %>%\n  summarise(avg = mean(values, na.rm =TRUE), \n            std = sd(values, na.rm =TRUE)\n            ) %>%\n  mutate(mean_std  = sprintf(\"%.1f\\u00b1%.1f\", avg, std), \n         median_IQR= sprintf(\"%.0f (%.0f-%.0f)\", p50, p25, p75)) %>%\n  select(sexgp, variables, mean_std) %>%\n  pivot_wider(names_from = sexgp, values_from = c(mean_std)) -> tab1\ntab1 %>% htmlTable(caption = \"Table 1. Basic Characteristics of study population\")\n\n\n\n\n\nTable 1. Basic Characteristics of study population\n\nvariables\nMen\nWomen\n\n\n\n\n1\nAGE\n43.7±12.2\n45.1±12.3\n\n\n2\nsleep1\n4.5±0.7\n4.4±0.8\n\n\n3\nsleep2\n4.5±0.8\n4.4±0.9\n\n\n4\nsleep3\n4.3±0.9\n4.2±0.9"
  },
  {
    "objectID": "245_datamanipulation_for_table.html#count-and-distribution",
    "href": "245_datamanipulation_for_table.html#count-and-distribution",
    "title": "5  보건학표_1",
    "section": "5.4 Count and Distribution",
    "text": "5.4 Count and Distribution\nheal_prob1 이 요통 변수라고 했었는데요, 1이 요통이 있다. 2가 요통이 없다 입니다. 이것을 표로 만들어 보겠습니다. ### 하나씩 반복 하나씩 반복하는게 가장 기본입니다. count를 사용하겠습니다. 요통이 몇몇 있나요?\n\ndat1 %>% count(heal_prob1)\n\n# A tibble: 2 × 2\n  heal_prob1     n\n  <dbl+lbl>  <int>\n1 1 [있다]    6939\n2 2 [없다]   20952\n\n\n분율, 비율, 유병률을 나타내면 어떻게 될까요. 전체 합을 sum으로 만들고 이때 비율을 만들어야 합니다.\n\ndat1 %>% count(heal_prob1) %>%\n  mutate(total = sum(n)) %>%\n  mutate(prob = n/total)\n\n# A tibble: 2 × 4\n  heal_prob1     n total  prob\n  <dbl+lbl>  <int> <int> <dbl>\n1 1 [있다]    6939 27891 0.249\n2 2 [없다]   20952 27891 0.751\n\n\n남자만 해보겠습니다.\n\ndat1 %>% \n  filter(TSEX==1) %>%\n  count(heal_prob1) %>%\n  mutate(prob= n/sum(n)) \n\n# A tibble: 2 × 3\n  heal_prob1     n  prob\n  <dbl+lbl>  <int> <dbl>\n1 1 [있다]    2930 0.223\n2 2 [없다]   10185 0.777\n\n\n여자만 해보세요.\n\n5.4.1 Group_by summary and Table 1\ngroup_by를 이용해 보겠습니다. 이면 위에서 연령을 이용한 방법을 실습했는데, 그것과 동일합니다\n\ndat1 %>%\n  group_by(TSEX) %>%\n  count(heal_prob1) %>%\n  mutate(prob = n/sum(n))\n\n# A tibble: 4 × 4\n# Groups:   TSEX [2]\n  TSEX      heal_prob1     n  prob\n  <dbl+lbl> <dbl+lbl>  <int> <dbl>\n1 1 [남성]  1 [있다]    2930 0.223\n2 1 [남성]  2 [없다]   10185 0.777\n3 2 [여성]  1 [있다]    4009 0.271\n4 2 [여성]  2 [없다]   10767 0.729\n\n\n익숙한 형태로 표시해 보겠습니다. 그리고 필요한 것만 남겨 보겠습니다 .\n\ndat1 %>%\n  group_by(TSEX) %>%\n  count(heal_prob1) %>%\n  mutate(prob = n/sum(n)) %>%\n  mutate(smry1 = sprintf(\"%s (%.1f%%)\", n, prob*100)) %>%\n  select(TSEX, heal_prob1, smry1)\n\n# A tibble: 4 × 3\n# Groups:   TSEX [2]\n  TSEX      heal_prob1 smry1        \n  <dbl+lbl> <dbl+lbl>  <chr>        \n1 1 [남성]  1 [있다]   2930 (22.3%) \n2 1 [남성]  2 [없다]   10185 (77.7%)\n3 2 [여성]  1 [있다]   4009 (27.1%) \n4 2 [여성]  2 [없다]   10767 (72.9%)\n\n\n이번에는 연령을 5세단위로 바꾸로 각 연령의 분포를 확인해 보겠습니다.\n\ndat1 <-dat1 %>% \n  mutate(agegp = case_when(\n    AGE <25 ~ \"<25\",\n    AGE <30 ~ \"<30\", \n    AGE <35 ~ \"<35\", \n    AGE <40 ~ \"<40\", \n    AGE <45 ~ \"<45\", \n    AGE <50 ~ \"<50\",\n    AGE <55 ~ \"<55\", \n    AGE <60 ~ \"<60\",\n    TRUE ~ \"\\u226560\" # 나머지는 모두 >65 (\\u2265는 크거나 같다는 symbol)\n  )) \n\ndat1 %>%\n  group_by(TSEX) %>%\n  count(agegp) %>%\n  mutate(prob = n/sum(n)) %>%\n  mutate(smry1 = sprintf(\"%s (%.1f%%)\", n, prob*100)) %>%\n  select(TSEX, agegp, smry1) %>%\n  arrange(TSEX, agegp)\n\n# A tibble: 18 × 3\n# Groups:   TSEX [2]\n   TSEX      agegp smry1       \n   <dbl+lbl> <chr> <chr>       \n 1 1 [남성]  <25   604 (4.6%)  \n 2 1 [남성]  <30   1334 (10.2%)\n 3 1 [남성]  <35   1498 (11.4%)\n 4 1 [남성]  <40   1812 (13.8%)\n 5 1 [남성]  <45   1810 (13.8%)\n 6 1 [남성]  <50   1691 (12.9%)\n 7 1 [남성]  <55   1464 (11.2%)\n 8 1 [남성]  <60   1323 (10.1%)\n 9 1 [남성]  ≥60   1579 (12.0%)\n10 2 [여성]  <25   727 (4.9%)  \n11 2 [여성]  <30   1242 (8.4%) \n12 2 [여성]  <35   1477 (10.0%)\n13 2 [여성]  <40   1597 (10.8%)\n14 2 [여성]  <45   1730 (11.7%)\n15 2 [여성]  <50   2013 (13.6%)\n16 2 [여성]  <55   2167 (14.7%)\n17 2 [여성]  <60   1972 (13.3%)\n18 2 [여성]  ≥60   1851 (12.5%)\n\n\n\n\n5.4.2 Long File and Table 1\n그럼 이번에는 요통과 연령집단을 동시에 바꾸어 보겠습니다.\n\ndat1 %>%\n  mutate(backpain= case_when(heal_prob1==1 ~ \"pain\", \n                             TRUE ~ \"no-pain\")) %>%\n  select(sexgp, agegp, backpain) %>%\n  pivot_longer(-c(sexgp), names_to =\"variables\", values_to = \"values\")  %>%\n  group_by(sexgp, variables) %>%\n  count(values) %>%\n  mutate(prob = n/sum(n)) %>%\n  mutate(smry1 = sprintf(\"%s (%.1f%%)\", n, prob*100)) %>%\n  select(-n, -prob) %>%\n  pivot_wider(names_from = sexgp, values_from = smry1) -> tab2\n\nhtml 테이블로 살펴 보겠습니다.\n\ntab2 %>% htmlTable()\n\n\n\n\n\nvariables\nvalues\nMen\nWomen\n\n\n\n\n1\nagegp\n<25\n604 (4.6%)\n727 (4.9%)\n\n\n2\nagegp\n<30\n1334 (10.2%)\n1242 (8.4%)\n\n\n3\nagegp\n<35\n1498 (11.4%)\n1477 (10.0%)\n\n\n4\nagegp\n<40\n1812 (13.8%)\n1597 (10.8%)\n\n\n5\nagegp\n<45\n1810 (13.8%)\n1730 (11.7%)\n\n\n6\nagegp\n<50\n1691 (12.9%)\n2013 (13.6%)\n\n\n7\nagegp\n<55\n1464 (11.2%)\n2167 (14.7%)\n\n\n8\nagegp\n<60\n1323 (10.1%)\n1972 (13.3%)\n\n\n9\nagegp\n≥60\n1579 (12.0%)\n1851 (12.5%)\n\n\n10\nbackpain\nno-pain\n10185 (77.7%)\n10767 (72.9%)\n\n\n11\nbackpain\npain\n2930 (22.3%)\n4009 (27.1%)\n\n\n\n\n\n무슨 생각이 드시죠? tab1과 tab2를 합치면 좋겠다는 생각이 드시죠, tab1에는 values 라는 변수가 없습니다 .그래서 합치기 어렵습니다. values 라는 변수를 생성하고 합쳐 보겠습니다.\n\ntab1 = tab1 %>% mutate(values = \"\") %>% select(variables, values, Men, Women) \n\nrbind(tab1, tab2) %>%\n  htmlTable()\n\n\n\n\n\nvariables\nvalues\nMen\nWomen\n\n\n\n\n1\nAGE\n\n43.7±12.2\n45.1±12.3\n\n\n2\nsleep1\n\n4.5±0.7\n4.4±0.8\n\n\n3\nsleep2\n\n4.5±0.8\n4.4±0.9\n\n\n4\nsleep3\n\n4.3±0.9\n4.2±0.9\n\n\n5\nagegp\n<25\n604 (4.6%)\n727 (4.9%)\n\n\n6\nagegp\n<30\n1334 (10.2%)\n1242 (8.4%)\n\n\n7\nagegp\n<35\n1498 (11.4%)\n1477 (10.0%)\n\n\n8\nagegp\n<40\n1812 (13.8%)\n1597 (10.8%)\n\n\n9\nagegp\n<45\n1810 (13.8%)\n1730 (11.7%)\n\n\n10\nagegp\n<50\n1691 (12.9%)\n2013 (13.6%)\n\n\n11\nagegp\n<55\n1464 (11.2%)\n2167 (14.7%)\n\n\n12\nagegp\n<60\n1323 (10.1%)\n1972 (13.3%)\n\n\n13\nagegp\n≥60\n1579 (12.0%)\n1851 (12.5%)\n\n\n14\nbackpain\nno-pain\n10185 (77.7%)\n10767 (72.9%)\n\n\n15\nbackpain\npain\n2930 (22.3%)\n4009 (27.1%)"
  },
  {
    "objectID": "245_datamanipulation_for_table.html#정리-1",
    "href": "245_datamanipulation_for_table.html#정리-1",
    "title": "5  보건학표_1",
    "section": "5.5 정리 1",
    "text": "5.5 정리 1\n\n원하는 데이터를 불러옴\n원하는 변수를 선정\n\n관심 변수 (종속, 독립)\n\n변수 값을 살펴 보기\n\n숫자 인지 아닌지\nmissing value 가 얼마 인지\n제외할 변수가 얼마인지\n\n대표값 생성\n\ncount 함수 사용, prob 변수 생성\n\n표 생성\n\n반복\ngroup_by\nlong file"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "보건학데이터과학 실습",
    "section": "",
    "text": "소개"
  },
  {
    "objectID": "index.html#보건학",
    "href": "index.html#보건학",
    "title": "보건학데이터과학 실습",
    "section": "보건학",
    "text": "보건학\n보건학은 인간과 그들의 사회의 건강을 향상시키기 위한 과학입니다. 보건학은 의학에서 사회과학에 이르기까지 여러 학문과 밀접하게 연관되어 있습니다. 따라서, 다학제적 접근법은 보건학 전문가에게 가장 중요한 기술 중 하나입니다."
  },
  {
    "objectID": "index.html#보건학-데이터과학",
    "href": "index.html#보건학-데이터과학",
    "title": "보건학데이터과학 실습",
    "section": "보건학 데이터과학",
    "text": "보건학 데이터과학\n데이터 과학은 크게 데이터를 수집, 처리, 분석하고, 그 결과를 해석하여 의사결정이나 예측, 분류 등의 작업을 수행하는 분야입니다. 이를 위해 프로그래밍, 통계학, 머신러닝 및 도메인 지식을 종합적으로 활용합니다. 이러한 기술을 보건학에 접목시키는 것이 보건학 데이터과학입니다.\n보건학 데이터과학의 주요 특징은 다음과 같습니다:\n\n다양한 데이터의 수집 및 관리:\n\n보건학에서는 환자 기록, 임상 데이터, 역학 조사 데이터, 환경 데이터 등 다양한 유형의 데이터를 다룹니다. 이러한 데이터의 효율적인 수집과 관리는 보건학의 데이터과학에서 중요한 부분을 차지합니다.\n\n통계 및 머신러닝의 적용:\n\n공공보건의 문제를 해결하기 위해, 통계적 방법과 머신러닝 기술을 사용하여 데이터에서 통찰력을 얻거나 예측 모델을 만드는 작업을 수행합니다.\n\n데이터 시각화:\n\n복잡한 보건 데이터를 쉽게 이해하고 해석하기 위해 시각화 기술을 사용합니다. 이를 통해 정책 결정자나 일반 대중에게 데이터를 효과적으로 전달할 수 있습니다.\n\n재현성 및 공유 가능한 연구:\n\n보건학 데이터과학에서는 연구 결과의 재현성을 보장하고, 연구 결과를 다른 연구자와 공유할 수 있도록 투명한 방법을 추구합니다.\n\n도메인 지식:\n\n보건학 데이터과학자는 단순히 데이터과학의 기술만을 가지고 있는 것이 아니라, 보건학에 대한 깊은 이해도 필요합니다. 이를 통해 데이터를 올바르게 해석하고, 실제 보건 문제에 적절한 솔루션을 제시할 수 있습니다."
  },
  {
    "objectID": "index.html#보건학-데이터-과학-과학이-되려면",
    "href": "index.html#보건학-데이터-과학-과학이-되려면",
    "title": "보건학데이터과학 실습",
    "section": "보건학 데이터 과학, 과학이 되려면",
    "text": "보건학 데이터 과학, 과학이 되려면\n과학에서의 제현성 과학에서의 재현성은 연구 결과를 다른 연구자들이 동일한 조건 하에서 반복해서 얻을 수 있는지의 여부를 나타내는 중요한 원칙입니다. 재현성은 과학적 연구의 진정성과 신뢰성을 평가하는 기준 중 하나로 간주됩니다.\n보건학 데이터과학이 과학의 기준에 부합하려면 다음과 같은 재현성 요소들을 갖추어야 합니다\n\n데이터의 접근성:\n\n연구에 사용된 원본 데이터는 공개되어야 하며, 연구를 재현하려는 다른 연구자들이 접근할 수 있어야 합니다. 당연히 개인정보 보호와 관련된 법률 및 규정을 준수하면서, 필요한 경우 익명화 또는 변조된 형태로 데이터를 공개해야 합니다.\n\n분석 코드 및 소프트웨어의 공개:\n\n연구에 사용된 데이터 처리, 분석, 시각화 등의 코드와 사용된 소프트웨어의 버전 정보도 공개되어야 합니다.\n\n분석 방법론의 명확성:\n\n사용된 통계적 방법, 머신러닝 알고리즘, 모델링 접근법 등이 명확하게 기술되어야 합니다.\n\n외부 변수 및 제어:\n\n연구 과정에서 영향을 미칠 수 있는 외부 변수들에 대한 정보와 그것들을 어떻게 제어했는지에 대한 정보가 필요합니다.\n\n결과의 재현 가능성 평가:\n\n가능한 경우, 연구 결과의 재현 가능성을 평가하기 위해 독립된 데이터셋이나 방법론을 사용하여 검증을 시도해야 합니다.\n\n연구 환경의 명세:\n\n연구가 수행된 하드웨어 및 소프트웨어 환경, 그리고 이를 설정하기 위한 파라미터 등도 기록되어야 합니다. 이는 특히 계산적으로 복잡한 모델이나 시뮬레이션을 다룰 때 중요합니다.\n\n피어 리뷰:\n\n보건학 데이터과학 연구의 결과는 동료 평가 과정을 거쳐 검증되어야 합니다. 피어 리뷰는 연구의 품질과 재현성을 높이는 데 중요한 역할을 합니다.\n\n\n정리하면 아래와 같은 흐름데로 연구하게 됩니다.\n 이 튜토리얼에서는 R, Rstudio, markdown, Shiny server, PostgreSQL 및 github를 사용할 것입니다. R은 무료 오픈 소스 통계 언어로, 데이터 과학 분야에서 널리 사용됩니다. 가장 중요한 참고 자료는 Rafael A. Irizarry의 책과 Hadley Wickham의 책입니다. 아래와 같습니다."
  },
  {
    "objectID": "index.html#참고-books",
    "href": "index.html#참고-books",
    "title": "보건학데이터과학 실습",
    "section": "참고 books",
    "text": "참고 books\n\n\n\n\n\n\n\n\ntitle\nauthos\nurl\n\n\n\n\nIntroduction to Data Science with R\nRafael A. Irizarry\nhttps://rafalab.github.io/dsbook/\n\n\nR for Data Science\nGarrett Grolemund, Hadley Wickham\nhttps://r4ds.had.co.nz/index.html\n\n\n\n\nI hope you will get valuable experience with me.\n\n그럼 시작하겠습니다.!!! jinha"
  },
  {
    "objectID": "247_datamanipulation_for_table_2.html#데이터-준비",
    "href": "247_datamanipulation_for_table_2.html#데이터-준비",
    "title": "6  보건학표_2",
    "section": "6.1 데이터 준비",
    "text": "6.1 데이터 준비\n데이터 표를 만드는 실습은 6차 근로환경조사 자료를 통해 실습할 것입니다.. 자료는 안전보건공단, 근로환경조사 원시자료 사이트 (http://kosha.or.kr/kosha/data/primitiveData.do) 에서 신청할 수 있습니다..\n\nrm(list=ls())\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif(!require(\"htmlTable\")) install.packages(\"htmlTable\")\nif(!require(\"haven\")) install.packages(\"haven\")\nif(!require(\"broom\")) install.packages(\"broom\")\n\n데이터 표를 만드는 실습은 6차 근로환경조사 자료를 통해 실습할 것입니다.. 자료는 안전보건공단, 근로환경조사 원시자료 사이트 (http://kosha.or.kr/kosha/data/primitiveData.do) 에서 신청할 수 있습니다.. 데이터를 불러오겠습니다. 안전보건공단 홈페이에서 자료를 다운 받는게 원칙입니다. 다만 실습을 빠르게 진행하기 위해서, dspubs.org 페이지에 있는 파일을 이용하겠습니다.   kwcsData6th.rds   자신의 folder에 data 라는 folder가 있는지 확인하십시오. data라는 폴더에 다운로드하고, 불러오도록 하겠습니다.\n\nurl <- \"https://raw.githubusercontent.com/jinhaslab/opendata/main/kwcs/kwcsData6th.rds\"\ndownload.file(url, \"data/tutorKWCS.rds\")\n\n\nkwcs = readRDS(\"data/tutorKWCS.rds\")"
  },
  {
    "objectID": "247_datamanipulation_for_table_2.html#분석-주제-선정",
    "href": "247_datamanipulation_for_table_2.html#분석-주제-선정",
    "title": "6  보건학표_2",
    "section": "6.2 분석 주제 선정",
    "text": "6.2 분석 주제 선정\n우선 수면 장애를 중심으로 연구를 하기로 했습니다. 이때 장시간 근무가 수면장애를 일으킬 수 있다는 가정을 했습니다. 기존 연구에서 유사한 내용이 있었기 때문입니다. 그 이유를 생각해보니, 오래 일하면 어떤 방식으로든 수면시간 자체가 줄어들 것으로 보였기 때문입니다. 우선 sleep disturbance, long working hours per week 이 정해졌습니다. 이후 연구방법론의 혼란변수 선정 방법이나, 연구자의 Domain knowledge에 따른 선정, 새로운 가설 개발 (originality) 위한 변수 선정등을 고려할 수 있습니다. 이러한 내용은 각각의 연구방법론 수업에서 학습하시기를 바랍니다.  여러 토론을 하다보니, 일을 마치고 집에 돌아온 후 해야할 일이 많은 경우 수면장애가 발생할 것 같은 느낌이 들었습니다. 이 것을 확인해 보고자 합니다.    즉, 장시간근로와 일과 삶의 균형에 따른 수면장애 관련성을 연구해 보고 싶습니다.\n\n  이제 data manipulation, long wide 변환을 통해 실습을 해보겠습니다.\n\n6.2.1 근로환경조사와 recode (선택사항)\n번외로 분석을 빠르게 진행하기 위해 recode에 대한 복습을 해 보겠습니다. recode는 아주 단순한 변경에 사용되는데요, 근로환경조사는 이미 변수를 1, 2, 3, 4, 5 의 순서를 Likert 척도로 사용하고 있습니다.\n\n근로환경조사 Likert 척도\n\n\n\n\n\n\n\n\n근로환경조사\nLikert 척도\n\n\n\n\n얼마나 자주 그렇습니까(freq)?\n“4.Always”,  “3.Often”, “2.Sometimes”, “1.Rarely”, “0.Never”\n\n\n얼마나 자주 그렇습니까(time)?\n“5.All of the time”, “4.Most of the time”, “3.More than half of the time”, “2.less than half of the time”, “1.Some of the time”, “0.At no time”\n\n\n얼마나 적당 합니까?\n“3.Very well”, “3.Well”, “2.Not very well”, “0.Not at all well”\n\n\n\n이것을 이용하면 매우 쉽게 정리할 수 있습니다. \n\nwwa4: 집안일 때문에 집중하기 어렵다가\n\n1: 항상그렇다,\n2: 대부분그렇다.\n3: 가끔 그렇다\n4: 별로 그렇지 않다.\n5: 전혀 그렇지 않다 로 되어 있습니다.\n\n\n\nrecode\n\n아래의 함수 결과를 살펴보면, 숫자의 경우 순서에 따라 문자를 어사인하는 것을 볼 수 있습니다. 데이터가 정형화되어 정리되어 있는 경우, 그리고 숫자인경우, case_when 이나 ifelse보다 더 쉬운 방법입니다.\n\nvars = c(1, 1, 1, 3, 3, 3, 2, 2, 2, 4, 4, 4)\nr1 = recode(vars, `1`= \"a\", `2`= \"b\", `3`= \"c\", `4`= \"d\")\nr1\n\n [1] \"a\" \"a\" \"a\" \"c\" \"c\" \"c\" \"b\" \"b\" \"b\" \"d\" \"d\" \"d\"\n\nr2 = recode(vars, \"a\", \"b\", \"c\", \"d\")\nr1 == r2\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n\n문자일 때는 어떨까요? 문자는 순서를 특정화 해주지 않았으므로 어렵습니다. 근로환경조사는 대부분 문자로 저장되어 있습니다.\n\nvars_char = as.character(vars)\nr3 = recode(vars_char, \"a\", \"b\", \"c\", \"d\")\nr3_n = recode(as.numeric(vars_char), \"a\", \"b\", \"c\", \"d\")\n\n이를 as.numeric을 통해 숫자로 변형시켜준 후 시행하면 잘 작동합니다.\n\nvars_char = as.character(vars)\nr3_n = recode(as.numeric(vars_char), \"a\", \"b\", \"c\", \"d\")\n\n이제 kwcs 에서 wwa1부터 wwa5까지를 가져와 역순으로 Likert 척도를 구해보겠습니다.\n\nwwas = kwcs %>% select(TSEX, contains(\"wwa\"))\nwwas %>% head()\n\n# A tibble: 6 × 11\n  TSEX      wwa1     wwa2    wwa3    wwa4    wwa5    wwa1gp wwa2gp wwa3gp wwa4gp\n  <dbl+lbl> <dbl+lb> <dbl+l> <dbl+l> <dbl+l> <dbl+l> <chr>  <chr>  <chr>  <chr> \n1 2 [여성]  5 [전혀… 4 [별… 5 [전… 5 [전… 5 [전… 0.Nev… 1.Rar… 0.Nev… 0.Nev…\n2 2 [여성]  4 [별로… 3 [가… 3 [가… 4 [별… 4 [별… 1.Rar… 2.Som… 2.Som… 1.Rar…\n3 2 [여성]  4 [별로… 4 [별… 4 [별… 4 [별… 4 [별… 1.Rar… 1.Rar… 1.Rar… 1.Rar…\n4 2 [여성]  5 [전혀… 5 [전… 5 [전… 5 [전… 5 [전… 0.Nev… 0.Nev… 0.Nev… 0.Nev…\n5 1 [남성]  5 [전혀… 5 [전… 5 [전… 5 [전… 5 [전… 0.Nev… 0.Nev… 0.Nev… 0.Nev…\n6 2 [여성]  5 [전혀… 4 [별… 4 [별… 5 [전… 5 [전… 0.Nev… 1.Rar… 1.Rar… 0.Nev…\n# ℹ 1 more variable: wwa5gp <chr>\n\n\nQuizz1: wwa1 변수에서 1의 값을 갖는 것은 남녀 별로 각각 몇명일까요? (script 안에 count 를 이용해서 작성해 보세요)\n\nwwas %>%\n  group_by(TSEX) %>%\n  [ script     ]\n\n이제 recode를 이용해 변환해 보겠습니다.\n\nwwa 관련 변수를\n\n1: 항상그렇다 → “4.Always”\n2: 대부분그렇다 → “3.Often”\n3: 가끔 그렇다 → “2.Sometimes”\n4: 별로 그렇지 않다 → “1.Rarely”\n5: 전혀 그렇지 않다 →“0.Never” 로 변경해 보겠습니다.  첫번째는 case_when으로 두번째는 recode로 변경했습니다. 누가 더 쉬운가요?\n\n\n\ntest = wwas %>%\n  mutate(wwa1gp1 = case_when(\n    wwa1 ==1 ~ \"4.Always\",\n    wwa1 ==2 ~ \"3.Often\", \n    wwa1 ==3 ~ \"2.Sometimes\", \n    wwa1 ==4 ~ \"1.Rarely\",\n    wwa1 ==5 ~ \"0.Never\" \n  )) %>%\n  mutate(wwa1gp2 = recode(as.numeric(wwa1), \n                          \"4.Always\",\"3.Often\",\"2.Sometimes\", \"1.Rarely\",\"0.Never\" \n                          )) \ntest %>%\n  mutate(diff = wwa1gp1 == wwa1gp2) %>%\n  pull(diff) %>% table(.)\n\n.\n TRUE \n41108 \n\n\n코드가 길어지는 것은 누군가와 소통하는데 장벽이 될수 있습니다. 반복적인 것은 함수를 만들어 요약할 수 있습니다.\n\nLikerts = function(x){\n  recode(as.numeric(x), \n         \"4.Always\",\"3.Often\",\"2.Sometimes\", \"1.Rarely\",\"0.Never\" \n         )\n}\n\nwwas %>%\n  mutate(wwa1gp1 = recode(as.numeric(wwa1), \n                          \"4.Always\",\"3.Often\",\"2.Sometimes\", \"1.Rarely\",\"0.Never\" \n                          )) %>%\n  mutate(wwa1gp2 = Likerts(wwa1)) %>%\n  mutate(diff = wwa1gp1 == wwa1gp2) %>%\n  pull(diff) %>% table(.)\n\n.\n TRUE \n41108 \n\n\n\n\n6.2.2 근로환경조사 기본 변수 생성\ndata manipulation에서 실습한 내용을 통해 변수를 생성해 보겠습니다.\n\n# data manip function\nLikert5f = function(x){dplyr::recode(as.numeric(x), \n         \"4.Always\",\"3.Often\",\"2.Sometimes\", \"1.Rarely\",\"0.Never\" )}\n\n# data step start ----------\n\ndat1 = kwcs %>%\n  filter(AGE <70) %>%\n  filter(AGE >18) %>%\n  # sleep --------\n  filter(!is.na(sleep1)&!is.na(sleep2)&!is.na(sleep3)) %>%\n  filter(sleep1 %in% c(1:5), \n         sleep2 %in% c(1:5), \n         sleep3 %in% c(1:5)) %>%\n  mutate(sleep1in = 5-sleep1, \n         sleep2in = 5-sleep2,\n         sleep3in = 5-sleep3\n         ) %>%\n  mutate(sleepgp = case_when(\n    sleep1in + sleep2in+ sleep3in >=6 ~ \"1.sleep disturbance\", \n    TRUE ~ \"0.non distrubance\"\n  )) %>%\n  # work life balances -------------\n  filter(!is.na(wbalance), !is.na(wwa1), !is.na(wwa2), !is.na(wwa3), !is.na(wwa4), !is.na(wwa5)) %>%\n  filter(!is.na(wbalance)) %>%\n  mutate(wbalancegp = case_when(\n    wbalance %in% c(1, 2) ~ \"0.balance\", \n    TRUE ~ \"1.non balance\"\n  )) %>%\n  mutate(wwa1gp=Likert5f(wwa1), wwa2gp=Likert5f(wwa2),  wwa3gp=Likert5f(wwa3), \n         wwa4gp=Likert5f(wwa4), wwa5gp=Likert5f(wwa5), \n         ) %>%\n  # job and sex, agegp  ----------\n  filter(!is.na(job1))%>%\n  filter(job1 %in% c(1, 2, 3)) %>%\n  mutate(sexgp = case_when(\n    TSEX ==1 ~ \"Men\", \n    TRUE ~ \"Women\"\n  )) %>%\n  mutate(agegp = case_when(AGE <25 ~ \"<25\", AGE <30 ~ \"<30\",  AGE <35 ~ \"<35\", \n    AGE <40 ~ \"<40\", AGE <45 ~ \"<45\", AGE <50 ~ \"<50\",AGE <55 ~ \"<55\", AGE <60 ~ \"<60\",\n    TRUE ~ \"\\u226560\" # 나머지는 모두 >65 (\\u2265는 크거나 같다는 symbol)\n  )) %>%\n  filter(!is.na(edu)) %>% filter(edu %in% c(1:7)) %>%\n  mutate(edugp = case_when(\n    edu %in% c(1:3) ~    \"2.middle school or below\",\n    edu %in% c(4  ) ~    \"1.high school\",\n    edu %in% c(5:7)   ~  \"0.university or more\"\n  )) %>%\n  mutate(njob=case_when(\n    job1 %in% c(2, 3) ~ \"1.njob\", \n    TRUE ~ \"0.one-job\")) %>%\n  # back pains -----------\n  mutate(backpain= case_when(\n    heal_prob1==1 ~ \"pain\", \n    TRUE ~ \"no-pain\")) %>%\n  # emp_type,working hours, shiftwork, work life balance -------\n  filter(!is.na(emp_type)) %>%\n  filter(emp_type %in% c(1:4)) %>%\n  mutate(empgp = case_when(\n    emp_type ==1 ~ \"2.own-account worker\", \n    emp_type ==2 ~ \"1.employer/self-employer\", \n    emp_type ==3 ~ \"0.paid-worker\", \n    emp_type ==4 ~ \"3.unpaind family work\"\n  )) %>%\n  filter(!is.na(wtime_week)) %>%\n  mutate(whgp=case_when(\n    wtime_week < 35 ~ \"<35\", \n    wtime_week < 40 ~ \"<40\", \n    wtime_week < 52 ~ \"<52\", \n    wtime_week < 60 ~ \"<60\", \n    TRUE ~ \"\\u226560\", \n  )) %>%\n  filter(!is.na(wtime_length5)) %>%\n  filter(wtime_length5 %in% c(1, 2)) %>%\n  mutate(shiftWork = case_when(\n    wtime_length5 ==1 ~ \"1.shift work\", \n    TRUE ~ \"0.non shift work\"\n  )) %>%\n  filter(!is.na(wtime_resilience)) %>%\n  mutate(shortReturn = case_when(\n    wtime_resilience ==1 ~ \"1.short return\", \n    TRUE ~ \"0.non short return\"\n  )) %>%\n  filter(!is.na(satisfaction)) %>%\n  filter(satisfaction %in% c(1:4)) %>%\n  mutate(satisInv = 5-satisfaction) %>%\n  mutate(shiftShort=case_when(\n    shiftWork == \"1.shift work\" & shortReturn == \"1.short return\" ~ \"3.shift work with short return\", \n    shiftWork == \"1.shift work\" & shortReturn != \"1.short return\" ~ \"2.shift work\", \n    shiftWork != \"1.shift work\" & shortReturn == \"1.short return\" ~ \"1.day work with short return\", \n    shiftWork != \"1.shift work\" & shortReturn != \"1.short return\" ~ \"0.day work\", \n  ))"
  },
  {
    "objectID": "247_datamanipulation_for_table_2.html#근로환경조사-table-1-만들기",
    "href": "247_datamanipulation_for_table_2.html#근로환경조사-table-1-만들기",
    "title": "6  보건학표_2",
    "section": "6.3 근로환경조사 Table 1 만들기",
    "text": "6.3 근로환경조사 Table 1 만들기\n지금까지 작업을 통해 분석한 변수를 선정합니다. 이때 정리할 부분은 무엇으로 구분할지, 관심변수는 무엇인지 이중 명목변수와 연속변수는 무엇인지를 구분하는 것입니다.\n\n## Variables selection\nstratas  = c(\"sleepgp\")\ncatVars = c(\n  # interesting\n  #\"wbalancegp\",\n  \"wwa1gp\", \"wwa2gp\",\"wwa3gp\",\"wwa4gp\",\"wwa5gp\",\n  # confounder\n  #\"whgp\", \n  \"shortReturn\",#\"shiftWork\" , #\"njob\", \n  # demograhpics\n  \"sexgp\", #\"agegp\", \n  \"edugp\", \"empgp\" #, \"backpain\" \n)\nconVars = c(\"AGE\",\"satisfaction\")\n\n\n6.3.1 변수 값 요약하기\n아래 코드가 뜻하는 것은 무엇일까요? 하나하나 살펴보아야 합니다. Table을 만들때 long file 형태로 만든 것입니다.\n\ncatTab = dat1 %>%\n  select(stratas, all_of(catVars)) %>%\n  pivot_longer(-c(stratas), names_to = \"variables\", values_to =\"values\")%>%\n  group_by( variables, values) %>%\n  count(!!sym(stratas)) %>%\n  mutate(prob = n/sum(n), \n         smry= sprintf(\"%.0f (%.1f%%)\", n, prob*100)\n         ) %>%\n  select(-n, -prob) %>%\n  ungroup() %>%\n  pivot_wider(names_from = stratas, values_from =smry) \n\n아래 코드가 뜻하는 것은 무엇일까요? 하나하나 살펴보아야 합니다. Table을 만들때 long file 형태로 만든 것입니다.\n\nconTab = \n  dat1 %>%\n  select(stratas, all_of(conVars)) %>%\n  pivot_longer(-c(stratas), names_to = \"variables\", values_to =\"values\")%>%\n  group_by( !!sym(stratas), variables) %>%\n  summarise(avg = mean(values, na.rm =TRUE), \n            std = sd(values, na.rm =TRUE) \n            ) %>%\n  mutate(smry  = sprintf(\"%.1f\\u00b1%.1f\", avg, std)) %>%\n  select(stratas, variables, smry)%>%\n  ungroup() %>%\n  pivot_wider(names_from = stratas, values_from =smry) %>%\n  mutate(values =\"\") \n\n명목변수 요약 표 catTab과 연속편수 요약표 conTab을 합쳐 보겠습니다. rbind는 종으로 합친다는 뜻입니다.\n\ntabDat = rbind(catTab, conTab)\n\n\n\n6.3.2 P value 구하기.\n이제 P value를 구해보겠습니다. 명목변수는 카이검정, 연속변수는 T검정을 해보겠습니다.\n\nChisq-Test\n\nCross Table을 만든 다음, chisq.test() 명령을 통해 수행합니다.\n\ntab= data.frame(A = c(1000, 2000), \n           B = c(100,  300))\ntab\n\n     A   B\n1 1000 100\n2 2000 300\n\nchisq.test(tab)\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  tab\nX-squared = 10.821, df = 1, p-value = 0.001003\n\n\n\nT.Test\n\n두 연속변수로 구성된 Data를 만들고 t.test() 명령을 통해 수행합니다.\n\ntab = data.frame(A=rnorm(100), \n           B=rnorm(100)+0.3)\nt.test(tab)\n\n\n    One Sample t-test\n\ndata:  tab\nt = 3.5089, df = 199, p-value = 0.0005564\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n 0.1156374 0.4123731\nsample estimates:\nmean of x \n0.2640053 \n\n\n이것을 이용해서 카이검정과 T검정을 수행해보겠습니다.  가장 정확하면서 쉬운 방식은 반복하는 것입니다. 우리가 이미 변수 값을 long file을 통해 정리하는 것을 실습하였기 때문에, 이 방식도 long file을 이용하겠습니다. \n이때 중요한 개념임 map, nest, tidy가 나옵니다. \n\nmap, nest, tidy\n\n각 백터 값에 대해서 함수를 실행한다.\n\n1:5 %>%\n  map(function(x){x^2})\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 9\n\n[[4]]\n[1] 16\n\n[[5]]\n[1] 25\n\ntibble(a=1:5, b=6:10) %>%\n  map(sum)\n\n$a\n[1] 15\n\n$b\n[1] 40\n\n\n이번에는 좀 복잡한 것을 해보겠습니다 아래와 같이 두 집단에 대해서 size와 power를 각 20명에게 측정했다고 가정합시다. 그리고 size와 power를 동시에 측정하고 측정 순서대로 데이터를 정리한 것입니다. 이후 G1과 G2의 Size와 Power에 대해 T.test를 수행하겠습니다.\n\ntest = tibble(\n  Variables= rep(c(\"Size\",\"Power\"), each=20), \n  G1= c(rnorm(20), rnorm(20)), \n  G2= c(rnorm(20)-0.3, rnorm(20)+0.3), \n  )\n\n일반적 방식은 아래와 같습니다. 이것을 반복하면 되는 것입니다.\n\ntest %>% filter(Variables==\"Size\") %>%\n  select(-Variables) %>%\n  t.test(.)\n\n\n    One Sample t-test\n\ndata:  .\nt = 1.2216, df = 39, p-value = 0.2292\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n -0.1110549  0.4497403\nsample estimates:\nmean of x \n0.1693427 \n\nt.test(test[test$Variables==\"Size\", ]$G1, \n  test[test$Variables==\"Size\", ]$G2)\n\n\n    Welch Two Sample t-test\n\ndata:  test[test$Variables == \"Size\", ]$G1 and test[test$Variables == \"Size\", ]$G2\nt = 0.88965, df = 37.99, p-value = 0.3793\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.3154596  0.8100985\nsample estimates:\n mean of x  mean of y \n0.29300245 0.04568298 \n\n\n이에 이것을 반복 수행하기 위해, data를 slice 하여 하나의 list로 만드는과정을 하겠습니다. nest의 과정입니다. 이후 각 데이터에 map을 이용해서 반복 수행을 하겠습니다. 그리고 그 값을 정리하여 unnest하는 과정이 필요합니다. 필요한 값인 p. value만 남겨 정리합니다.\n\ntest1 = test %>%\n  nest(dat = -Variables) %>%\n  mutate(fit=map(dat, ~t.test(.x)), \n         tidied=map(fit, tidy)) \ntest1 %>% unnest(tidied) %>%\n  select(Variables, p.value)\n\n# A tibble: 2 × 2\n  Variables p.value\n  <chr>       <dbl>\n1 Size      0.229  \n2 Power     0.00790\n\n\n지금까지 사용한 것을 가지고, 명목변수에서는 Chisq-Test, 연속변수에서 t.test 를 수행하여 정리하겠습니다.\n\n명목변수, chisq.test\n\n\ncatPvalue = \n  dat1 %>%\n  select(stratas, catVars) %>%\n  pivot_longer(-c(stratas), names_to = \"variables\", values_to =\"values\")%>%\n  group_by(variables, values) %>%\n  count(!!sym(stratas)) %>%\n  pivot_wider(names_from = stratas, values_from =n) %>%\n  ungroup() %>%\n  select(-values) %>%\n  nest(dat = -variables) %>%\n  mutate(\n    fit = map(dat, \n              ~chisq.test(.x)), \n    tidied = map(fit, tidy)\n  ) %>%\n  unnest(tidied) %>%\n  select(variables, p.value) %>%\n  mutate(p.value = ifelse(p.value <0.001, \"<0.001\", sprintf(\"%.3f\", p.value)))\n\n\n연속변수, t.test\n\n\nconPvalue=dat1 %>%\n  mutate(stratas = !!sym(stratas)) %>%\n  select(stratas, conVars) %>%\n  pivot_longer(-c(stratas), names_to = \"variables\", values_to =\"values\") %>%\n  nest(dat = -variables) %>%\n  mutate(\n    fit   =map(dat, ~t.test(.$values ~ .$stratas)), \n    tidied=map(fit, tidy)\n  ) %>%\n  unnest(tidied) %>%\n  select(variables, p.value) %>%\n  mutate(p.value = ifelse(p.value <0.001, \"<0.001\", sprintf(\"%.3f\", p.value)))\n\n\nP.valeu 합치기\n\n\ntabPvalue = rbind(catPvalue, conPvalue)\n\n\n표가 어떤 순서대로 표현될지에 대한 순서를 정합니다.\n\n\nvarOrder = tibble(\"variables\"=c(catVars, conVars)) %>%\n  mutate(order = row_number())\nvarOrder\n\n# A tibble: 11 × 2\n   variables    order\n   <chr>        <int>\n 1 wwa1gp           1\n 2 wwa2gp           2\n 3 wwa3gp           3\n 4 wwa4gp           4\n 5 wwa5gp           5\n 6 shortReturn      6\n 7 sexgp            7\n 8 edugp            8\n 9 empgp            9\n10 AGE             10\n11 satisfaction    11"
  },
  {
    "objectID": "247_datamanipulation_for_table_2.html#table-1-정리하기",
    "href": "247_datamanipulation_for_table_2.html#table-1-정리하기",
    "title": "6  보건학표_2",
    "section": "6.4 Table 1 정리하기",
    "text": "6.4 Table 1 정리하기\n이제 변수값 요약과, p.value를 합치고, 순서에 맞게 정리하겠습니다.\n\ntab1 = tabDat %>%\n  left_join(tabPvalue, by=c(\"variables\")) %>%\n  left_join(varOrder, by = c(\"variables\")) %>%\n  arrange(order, values) %>%\n  group_by(variables) %>%\n  mutate(ranks = row_number()) %>%\n  mutate(p.value   = ifelse(ranks==min(ranks), p.value,   \"\")) %>% \n  mutate(variables = ifelse(ranks==min(ranks), variables, \"\")) %>%\n  ungroup() %>%\n  select(-order, -ranks)%>%\n  mutate(values = str_replace(values, \"[:digit:]\\\\.\", \"\"))\n\n이것을 htmlTable로 나타내면 다음과 같습니다.\n\ntab1 %>% htmlTable()\n\n\n\n\n\nvariables\nvalues\n0.non distrubance\n1.sleep disturbance\np.value\n\n\n\n\n1\nwwa1gp\nNever\n12222 (94.7%)\n684 (5.3%)\n<0.001\n\n\n2\n\nRarely\n12316 (94.5%)\n714 (5.5%)\n\n\n\n3\n\nSometimes\n9112 (90.3%)\n981 (9.7%)\n\n\n\n4\n\nOften\n3456 (82.8%)\n717 (17.2%)\n\n\n\n5\n\nAlways\n634 (70.0%)\n272 (30.0%)\n\n\n\n6\nwwa2gp\nNever\n12432 (95.4%)\n597 (4.6%)\n<0.001\n\n\n7\n\nRarely\n13682 (94.1%)\n863 (5.9%)\n\n\n\n8\n\nSometimes\n8882 (89.2%)\n1072 (10.8%)\n\n\n\n9\n\nOften\n2460 (79.4%)\n638 (20.6%)\n\n\n\n10\n\nAlways\n284 (58.9%)\n198 (41.1%)\n\n\n\n11\nwwa3gp\nNever\n13472 (95.2%)\n682 (4.8%)\n<0.001\n\n\n12\n\nRarely\n13938 (93.1%)\n1040 (6.9%)\n\n\n\n13\n\nSometimes\n7749 (89.9%)\n868 (10.1%)\n\n\n\n14\n\nOften\n2314 (79.5%)\n597 (20.5%)\n\n\n\n15\n\nAlways\n267 (59.6%)\n181 (40.4%)\n\n\n\n16\nwwa4gp\nNever\n18708 (94.1%)\n1169 (5.9%)\n<0.001\n\n\n17\n\nRarely\n14799 (91.6%)\n1362 (8.4%)\n\n\n\n18\n\nSometimes\n3348 (85.0%)\n592 (15.0%)\n\n\n\n19\n\nOften\n805 (80.7%)\n193 (19.3%)\n\n\n\n20\n\nAlways\n80 (60.6%)\n52 (39.4%)\n\n\n\n21\nwwa5gp\nNever\n19061 (93.9%)\n1245 (6.1%)\n<0.001\n\n\n22\n\nRarely\n14770 (91.6%)\n1349 (8.4%)\n\n\n\n23\n\nSometimes\n3180 (85.3%)\n550 (14.7%)\n\n\n\n24\n\nOften\n682 (79.8%)\n173 (20.2%)\n\n\n\n25\n\nAlways\n47 (48.0%)\n51 (52.0%)\n\n\n\n26\nshortReturn\nnon short return\n36183 (92.5%)\n2927 (7.5%)\n<0.001\n\n\n27\n\nshort return\n1557 (77.9%)\n441 (22.1%)\n\n\n\n28\nsexgp\nMen\n17892 (93.1%)\n1327 (6.9%)\n<0.001\n\n\n29\n\nWomen\n19848 (90.7%)\n2041 (9.3%)\n\n\n\n30\nedugp\nuniversity or more\n19597 (92.9%)\n1502 (7.1%)\n<0.001\n\n\n31\n\nhigh school\n14943 (91.9%)\n1318 (8.1%)\n\n\n\n32\n\nmiddle school or below\n3200 (85.4%)\n548 (14.6%)\n\n\n\n33\nempgp\npaid-worker\n25786 (92.4%)\n2122 (7.6%)\n<0.001\n\n\n34\n\nemployer/self-employer\n2539 (91.7%)\n229 (8.3%)\n\n\n\n35\n\nown-account worker\n8359 (90.5%)\n880 (9.5%)\n\n\n\n36\n\nunpaind family work\n1056 (88.5%)\n137 (11.5%)\n\n\n\n37\nAGE\n\n46.8±12.4\n49.7±11.9\n<0.001\n\n\n38\nsatisfaction\n\n2.1±0.5\n2.4±0.6\n<0.001\n\n\n\n\n\n\n6.4.1 htmlTable visulaization\n테이블이 너무 길기 때문에, wwa2, wwa3, wwa4, wwa5, 는 제외하고 표를 만들겠습니다.\n\ntab2 = tab1 %>% slice(-c(6:25))\ntab2 %>% \n  `rownames<-`(NULL)  %>%\n  htmlTable(rnames = FALSE) \n\n\n\n\n\nvariables\nvalues\n0.non distrubance\n1.sleep disturbance\np.value\n\n\n\n\nwwa1gp\nNever\n12222 (94.7%)\n684 (5.3%)\n<0.001\n\n\n\nRarely\n12316 (94.5%)\n714 (5.5%)\n\n\n\n\nSometimes\n9112 (90.3%)\n981 (9.7%)\n\n\n\n\nOften\n3456 (82.8%)\n717 (17.2%)\n\n\n\n\nAlways\n634 (70.0%)\n272 (30.0%)\n\n\n\nshortReturn\nnon short return\n36183 (92.5%)\n2927 (7.5%)\n<0.001\n\n\n\nshort return\n1557 (77.9%)\n441 (22.1%)\n\n\n\nsexgp\nMen\n17892 (93.1%)\n1327 (6.9%)\n<0.001\n\n\n\nWomen\n19848 (90.7%)\n2041 (9.3%)\n\n\n\nedugp\nuniversity or more\n19597 (92.9%)\n1502 (7.1%)\n<0.001\n\n\n\nhigh school\n14943 (91.9%)\n1318 (8.1%)\n\n\n\n\nmiddle school or below\n3200 (85.4%)\n548 (14.6%)\n\n\n\nempgp\npaid-worker\n25786 (92.4%)\n2122 (7.6%)\n<0.001\n\n\n\nemployer/self-employer\n2539 (91.7%)\n229 (8.3%)\n\n\n\n\nown-account worker\n8359 (90.5%)\n880 (9.5%)\n\n\n\n\nunpaind family work\n1056 (88.5%)\n137 (11.5%)\n\n\n\nAGE\n\n46.8±12.4\n49.7±11.9\n<0.001\n\n\nsatisfaction\n\n2.1±0.5\n2.4±0.6\n<0.001\n\n\n\n\n\n변수 이름을 변경하요 보기 좋게 변환시키고, cgroup을 이용하여 colum 부분을 조정합니다. Caption과 Footer를 작성하여 마무리 합니다.\n\ntab2 %>%\n  setNames(c(\"\", \"\", \"None\", \"Disturbance\", \"P value\")) %>%\n  htmlTable(\n    cgroup = c(\"\",  \"Sleep disturbance\", \"\"), \n    n.cgroup = c(2, 2, 1), \n    tfoot = \"P value calculated by Chisq-Test and T-Test\", \n    rnames = FALSE, \n    caption = \"Basic Characteristics according to Sleep disturbance\"\n  ) \n\n\n\n\n\nBasic Characteristics according to Sleep disturbance\n\n \nSleep disturbance \n\n\n\n\n \n \nNone\nDisturbance \n \nP value\n\n\n\n\nwwa1gp\nNever \n \n12222 (94.7%)\n684 (5.3%) \n \n<0.001\n\n\n\nRarely \n \n12316 (94.5%)\n714 (5.5%) \n \n\n\n\n\nSometimes \n \n9112 (90.3%)\n981 (9.7%) \n \n\n\n\n\nOften \n \n3456 (82.8%)\n717 (17.2%) \n \n\n\n\n\nAlways \n \n634 (70.0%)\n272 (30.0%) \n \n\n\n\nshortReturn\nnon short return \n \n36183 (92.5%)\n2927 (7.5%) \n \n<0.001\n\n\n\nshort return \n \n1557 (77.9%)\n441 (22.1%) \n \n\n\n\nsexgp\nMen \n \n17892 (93.1%)\n1327 (6.9%) \n \n<0.001\n\n\n\nWomen \n \n19848 (90.7%)\n2041 (9.3%) \n \n\n\n\nedugp\nuniversity or more \n \n19597 (92.9%)\n1502 (7.1%) \n \n<0.001\n\n\n\nhigh school \n \n14943 (91.9%)\n1318 (8.1%) \n \n\n\n\n\nmiddle school or below \n \n3200 (85.4%)\n548 (14.6%) \n \n\n\n\nempgp\npaid-worker \n \n25786 (92.4%)\n2122 (7.6%) \n \n<0.001\n\n\n\nemployer/self-employer \n \n2539 (91.7%)\n229 (8.3%) \n \n\n\n\n\nown-account worker \n \n8359 (90.5%)\n880 (9.5%) \n \n\n\n\n\nunpaind family work \n \n1056 (88.5%)\n137 (11.5%) \n \n\n\n\nAGE\n \n \n46.8±12.4\n49.7±11.9 \n \n<0.001\n\n\nsatisfaction\n \n \n2.1±0.5\n2.4±0.6 \n \n<0.001\n\n\n\nP value calculated by Chisq-Test and T-Test"
  },
  {
    "objectID": "247_datamanipulation_for_table_2.html#kwcsfunction",
    "href": "247_datamanipulation_for_table_2.html#kwcsfunction",
    "title": "6  보건학표_2",
    "section": "6.5 함수만들기",
    "text": "6.5 함수만들기\n지금가지 했던 일련의 과정을 함수로 정리하겠습니다.\n\nkwcsTabf = function(dat1, stratas, catVars, conVars){\nvarOrder = tibble(\"variables\"=c(catVars, conVars)) %>%\n  mutate(order = row_number())\n  \ncatTab = dat1 %>%\n  select(stratas, all_of(catVars)) %>%\n  pivot_longer(-c(stratas), names_to = \"variables\", values_to =\"values\")%>%\n  group_by( variables, values) %>%\n  count(!!sym(stratas)) %>%\n  mutate(prob = n/sum(n), \n         smry= sprintf(\"%.0f (%.1f%%)\", n, prob*100)\n  ) %>%\n  select(-n, -prob) %>%\n  ungroup() %>%\n  pivot_wider(names_from = stratas, values_from =smry) \n\nconTab = \n  dat1 %>%\n  select(stratas, all_of(conVars)) %>%\n  pivot_longer(-c(stratas), names_to = \"variables\", values_to =\"values\")%>%\n  group_by( !!sym(stratas), variables) %>%\n  summarise(avg = mean(values, na.rm =TRUE), \n            std = sd(values, na.rm =TRUE) \n  ) %>%\n  mutate(smry  = sprintf(\"%.1f\\u00b1%.1f\", avg, std)) %>%\n  select(stratas, variables, smry)%>%\n  ungroup() %>%\n  pivot_wider(names_from = stratas, values_from =smry) %>%\n  mutate(values =\"\") \ntabDat = rbind(catTab, conTab)\n\n\ncatPvalue = \n  dat1 %>%\n  select(stratas, catVars) %>%\n  pivot_longer(-c(stratas), names_to = \"variables\", values_to =\"values\")%>%\n  group_by(variables, values) %>%\n  count(!!sym(stratas)) %>%\n  pivot_wider(names_from = stratas, values_from =n) %>%\n  ungroup() %>%\n  select(-values) %>%\n  nest(dat = -variables) %>%\n  mutate(\n    fit = map(dat, \n              ~chisq.test(.x)), \n    tidied = map(fit, tidy)\n  ) %>%\n  unnest(tidied) %>%\n  select(variables, p.value) %>%\n  mutate(p.value = ifelse(p.value <0.001, \"<0.001\", sprintf(\"%.3f\", p.value)))\n\nconPvalue=dat1 %>%\n  mutate(stratas = !!sym(stratas)) %>%\n  select(stratas, conVars) %>%\n  pivot_longer(-c(stratas), names_to = \"variables\", values_to =\"values\") %>%\n  nest(dat = -variables) %>%\n  mutate(\n    fit   =map(dat, ~t.test(.$values ~ .$stratas)), \n    tidied=map(fit, tidy)\n  ) %>%\n  unnest(tidied) %>%\n  select(variables, p.value) %>%\n  mutate(p.value = ifelse(p.value <0.001, \"<0.001\", sprintf(\"%.3f\", p.value)))\n\ntabPvalue = rbind(catPvalue, conPvalue)\n\ntab1 = tabDat %>%\n  left_join(tabPvalue, by=c(\"variables\")) %>%\n  left_join(varOrder, by = c(\"variables\")) %>%\n  arrange(order, values) %>%\n  group_by(variables) %>%\n  mutate(ranks = row_number()) %>%\n  mutate(p.value   = ifelse(ranks==min(ranks), p.value,   \"\")) %>% \n  mutate(variables = ifelse(ranks==min(ranks), variables, \"\")) %>%\n  ungroup() %>%\n  select(-order, -ranks)%>%\n  mutate(values = str_replace(values, \"[:digit:]\\\\.\", \"\"))\nreturn(tab1)\n}\n\n층화변수, 명목변수, 연속변수를 구성하여 함수를 실행해 보겠습니다.\n\n## Variables selection\nstratas  = c(\"sleepgp\")\ncatVars = c(\n  # interesting\n  #\"wbalancegp\",\n  \"wwa1gp\", \"wwa2gp\",\"wwa3gp\",\"wwa4gp\",\"wwa5gp\",\n  # confounder\n  #\"whgp\", \n  \"shortReturn\",\"shiftWork\" , \"njob\", \n  # demograhpics\n  \"sexgp\", \"agegp\", \n  \"edugp\", \"empgp\" #, backpain\" \n)\nconVars = c(\"AGE\",\"satisfaction\")\n\ntab1 = kwcsTabf(dat1=dat1, stratas = stratas, catVars = catVars, conVars = conVars)\ntab1 %>% \n  setNames(c(\"\", \"\", \"None\", \"Disturbance\", \"P value\")) %>%\n  htmlTable(\n    cgroup = c(\"\",  \"Sleep disturbance\", \"\"), \n    n.cgroup = c(2, 2, 1), \n    tfoot = \"P value calculated by Chisq-Test and T-Test\", \n    rnames = FALSE, \n    caption = \"Basic Characteristics according to Sleep disturbance\"\n  ) \n\n\n\n\n\nBasic Characteristics according to Sleep disturbance\n\n \nSleep disturbance \n\n\n\n\n \n \nNone\nDisturbance \n \nP value\n\n\n\n\nwwa1gp\nNever \n \n12222 (94.7%)\n684 (5.3%) \n \n<0.001\n\n\n\nRarely \n \n12316 (94.5%)\n714 (5.5%) \n \n\n\n\n\nSometimes \n \n9112 (90.3%)\n981 (9.7%) \n \n\n\n\n\nOften \n \n3456 (82.8%)\n717 (17.2%) \n \n\n\n\n\nAlways \n \n634 (70.0%)\n272 (30.0%) \n \n\n\n\nwwa2gp\nNever \n \n12432 (95.4%)\n597 (4.6%) \n \n<0.001\n\n\n\nRarely \n \n13682 (94.1%)\n863 (5.9%) \n \n\n\n\n\nSometimes \n \n8882 (89.2%)\n1072 (10.8%) \n \n\n\n\n\nOften \n \n2460 (79.4%)\n638 (20.6%) \n \n\n\n\n\nAlways \n \n284 (58.9%)\n198 (41.1%) \n \n\n\n\nwwa3gp\nNever \n \n13472 (95.2%)\n682 (4.8%) \n \n<0.001\n\n\n\nRarely \n \n13938 (93.1%)\n1040 (6.9%) \n \n\n\n\n\nSometimes \n \n7749 (89.9%)\n868 (10.1%) \n \n\n\n\n\nOften \n \n2314 (79.5%)\n597 (20.5%) \n \n\n\n\n\nAlways \n \n267 (59.6%)\n181 (40.4%) \n \n\n\n\nwwa4gp\nNever \n \n18708 (94.1%)\n1169 (5.9%) \n \n<0.001\n\n\n\nRarely \n \n14799 (91.6%)\n1362 (8.4%) \n \n\n\n\n\nSometimes \n \n3348 (85.0%)\n592 (15.0%) \n \n\n\n\n\nOften \n \n805 (80.7%)\n193 (19.3%) \n \n\n\n\n\nAlways \n \n80 (60.6%)\n52 (39.4%) \n \n\n\n\nwwa5gp\nNever \n \n19061 (93.9%)\n1245 (6.1%) \n \n<0.001\n\n\n\nRarely \n \n14770 (91.6%)\n1349 (8.4%) \n \n\n\n\n\nSometimes \n \n3180 (85.3%)\n550 (14.7%) \n \n\n\n\n\nOften \n \n682 (79.8%)\n173 (20.2%) \n \n\n\n\n\nAlways \n \n47 (48.0%)\n51 (52.0%) \n \n\n\n\nshortReturn\nnon short return \n \n36183 (92.5%)\n2927 (7.5%) \n \n<0.001\n\n\n\nshort return \n \n1557 (77.9%)\n441 (22.1%) \n \n\n\n\nshiftWork\nnon shift work \n \n35056 (91.9%)\n3073 (8.1%) \n \n<0.001\n\n\n\nshift work \n \n2684 (90.1%)\n295 (9.9%) \n \n\n\n\nnjob\none-job \n \n37471 (91.9%)\n3317 (8.1%) \n \n<0.001\n\n\n\nnjob \n \n269 (84.1%)\n51 (15.9%) \n \n\n\n\nsexgp\nMen \n \n17892 (93.1%)\n1327 (6.9%) \n \n<0.001\n\n\n\nWomen \n \n19848 (90.7%)\n2041 (9.3%) \n \n\n\n\nagegp\n<25 \n \n1359 (96.6%)\n48 (3.4%) \n \n<0.001\n\n\n\n<30 \n \n2697 (94.3%)\n163 (5.7%) \n \n\n\n\n\n<35 \n \n3308 (93.6%)\n225 (6.4%) \n \n\n\n\n\n<40 \n \n3995 (92.3%)\n334 (7.7%) \n \n\n\n\n\n<45 \n \n4414 (92.2%)\n372 (7.8%) \n \n\n\n\n\n<50 \n \n4934 (92.7%)\n388 (7.3%) \n \n\n\n\n\n<55 \n \n5300 (91.9%)\n465 (8.1%) \n \n\n\n\n\n<60 \n \n5099 (90.0%)\n566 (10.0%) \n \n\n\n\n\n≥60 \n \n6634 (89.2%)\n807 (10.8%) \n \n\n\n\nedugp\nuniversity or more \n \n19597 (92.9%)\n1502 (7.1%) \n \n<0.001\n\n\n\nhigh school \n \n14943 (91.9%)\n1318 (8.1%) \n \n\n\n\n\nmiddle school or below \n \n3200 (85.4%)\n548 (14.6%) \n \n\n\n\nempgp\npaid-worker \n \n25786 (92.4%)\n2122 (7.6%) \n \n<0.001\n\n\n\nemployer/self-employer \n \n2539 (91.7%)\n229 (8.3%) \n \n\n\n\n\nown-account worker \n \n8359 (90.5%)\n880 (9.5%) \n \n\n\n\n\nunpaind family work \n \n1056 (88.5%)\n137 (11.5%) \n \n\n\n\nAGE\n \n \n46.8±12.4\n49.7±11.9 \n \n<0.001\n\n\nsatisfaction\n \n \n2.1±0.5\n2.4±0.6 \n \n<0.001\n\n\n\nP value calculated by Chisq-Test and T-Test"
  },
  {
    "objectID": "248_datamanipulation_for_table_3.html#데이터-준비",
    "href": "248_datamanipulation_for_table_3.html#데이터-준비",
    "title": "7  보건학표_3",
    "section": "7.1 데이터 준비",
    "text": "7.1 데이터 준비\n데이터 표를 만드는 실습은 6차 근로환경조사 자료를 통해 실습할 것입니다.. 자료는 안전보건공단, 근로환경조사 원시자료 사이트 (http://kosha.or.kr/kosha/data/primitiveData.do) 에서 신청할 수 있습니다..\n\nrm(list=ls())\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif(!require(\"htmlTable\")) install.packages(\"htmlTable\")\nif(!require(\"haven\")) install.packages(\"haven\")\nif(!require(\"broom\")) install.packages(\"broom\")\n\n데이터 표를 만드는 실습은 6차 근로환경조사 자료를 통해 실습할 것입니다.. 자료는 안전보건공단, 근로환경조사 원시자료 사이트 (http://kosha.or.kr/kosha/data/primitiveData.do) 에서 신청할 수 있습니다.. 데이터를 불러오겠습니다. 안전보건공단 홈페이에서 자료를 다운 받는게 원칙입니다. 다만 실습을 빠르게 진행하기 위해서, dspubs.org 페이지에 있는 파일을 이용하겠습니다.   kwcsData6th.rds   자신의 folder에 data 라는 folder가 있는지 확인하십시오. data라는 폴더에 다운로드하고, 불러오도록 하겠습니다.\n\nurl <- \"https://raw.githubusercontent.com/jinhaslab/opendata/main/kwcs/kwcsData6th.rds\"\ndownload.file(url, \"data/tutorKWCS.rds\")\n\n\nkwcs = readRDS(\"data/tutorKWCS.rds\")\n\n\n7.1.1 근로환경조사 기본 변수 생성 (선택)\ndata manipulation에서 실습한 내용을 통해 변수를 실습을 위한 변수를 생성해 보겠습니다. 이에 대한 자세한 과정은 이전 챔터에 있습니다. \nTable 1 변수 생성과정 챕터\n\n# data manip function\nLikert5f = function(x){dplyr::recode(as.numeric(x), \n         \"4.Always\",\"3.Often\",\"2.Sometimes\", \"1.Rarely\",\"0.Never\" )}\n\n# data step start ----------\n\ndat1 = kwcs %>%\n  filter(AGE <70) %>%\n  filter(AGE >18) %>%\n  # sleep --------\n  filter(!is.na(sleep1)&!is.na(sleep2)&!is.na(sleep3)) %>%\n  filter(sleep1 %in% c(1:5), \n         sleep2 %in% c(1:5), \n         sleep3 %in% c(1:5)) %>%\n  mutate(sleep1in = 5-sleep1, \n         sleep2in = 5-sleep2,\n         sleep3in = 5-sleep3\n         ) %>%\n  mutate(sleepgp = case_when(\n    sleep1in + sleep2in+ sleep3in >=6 ~ \"1.sleep disturbance\", \n    TRUE ~ \"0.non distrubance\"\n  )) %>%\n  # work live balances -------------\n  filter(!is.na(wbalance), !is.na(wwa1), !is.na(wwa2), !is.na(wwa3), !is.na(wwa4), !is.na(wwa5)) %>%\n  filter(!is.na(wbalance)) %>%\n  mutate(wbalancegp = case_when(\n    wbalance %in% c(1, 2) ~ \"0.balance\", \n    TRUE ~ \"1.non balance\"\n  )) %>%\n  mutate(wwa1gp=Likert5f(wwa1), wwa2gp=Likert5f(wwa2),  wwa3gp=Likert5f(wwa3), \n         wwa4gp=Likert5f(wwa4), wwa5gp=Likert5f(wwa5), \n         ) %>%\n  # job and sex, agegp  ----------\n  filter(!is.na(job1))%>%\n  filter(job1 %in% c(1, 2, 3)) %>%\n  mutate(sexgp = case_when(\n    TSEX ==1 ~ \"Men\", \n    TRUE ~ \"Women\"\n  )) %>%\n  mutate(agegp = case_when(AGE <25 ~ \"<25\", AGE <30 ~ \"<30\",  AGE <35 ~ \"<35\", \n    AGE <40 ~ \"<40\", AGE <45 ~ \"<45\", AGE <50 ~ \"<50\",AGE <55 ~ \"<55\", AGE <60 ~ \"<60\",\n    TRUE ~ \"\\u226560\" # 나머지는 모두 >65 (\\u2265는 크거나 같다는 symbol)\n  )) %>%\n  filter(!is.na(edu)) %>% filter(edu %in% c(1:7)) %>%\n  mutate(edugp = case_when(\n    edu %in% c(1:3) ~    \"2.middle school or below\",\n    edu %in% c(4  ) ~    \"1.high school\",\n    edu %in% c(5:7)   ~  \"0.university or more\"\n  )) %>%\n  mutate(njob=case_when(\n    job1 %in% c(2, 3) ~ \"1.njob\", \n    TRUE ~ \"0.one-job\")) %>%\n  # pains back -----------\n  mutate(backpain= case_when(\n    heal_prob1==1 ~ \"pain\", \n    TRUE ~ \"no-pain\")) %>%\n  # emp_type,working hours, shiftwork, work life balance -------\n  filter(!is.na(emp_type)) %>%\n  filter(emp_type %in% c(1:4)) %>%\n  mutate(empgp = case_when(\n    emp_type ==1 ~ \"2.own-account worker\", \n    emp_type ==2 ~ \"1.employer/self-employer\", \n    emp_type ==3 ~ \"0.paid-worker\", \n    emp_type ==4 ~ \"3.unpaind family work\"\n  )) %>%\n  filter(!is.na(wtime_week)) %>%\n  mutate(whgp=case_when(\n    wtime_week < 35 ~ \"<35\", \n    wtime_week < 40 ~ \"<40\", \n    wtime_week < 52 ~ \"<52\", \n    wtime_week < 60 ~ \"<60\", \n    TRUE ~ \"\\u226560\", \n  )) %>%\n  filter(!is.na(wtime_length5)) %>%\n  filter(wtime_length5 %in% c(1, 2)) %>%\n  mutate(shiftWork = case_when(\n    wtime_length5 ==1 ~ \"1.shift work\", \n    TRUE ~ \"0.non shift work\"\n  )) %>%\n  filter(!is.na(wtime_resilience)) %>%\n  mutate(shortReturn = case_when(\n    wtime_resilience ==1 ~ \"1.short return\", \n    TRUE ~ \"0.non short return\"\n  )) %>%\n  filter(!is.na(satisfaction)) %>%\n  filter(satisfaction %in% c(1:4)) %>%\n  mutate(satisInv = 5-satisfaction) %>%\n  mutate(shiftShort=case_when(\n    shiftWork == \"1.shift work\" & shortReturn == \"1.short return\" ~ \"3.shift work with short return\", \n    shiftWork == \"1.shift work\" & shortReturn != \"1.short return\" ~ \"2.shift work\", \n    shiftWork != \"1.shift work\" & shortReturn == \"1.short return\" ~ \"1.day work with short return\", \n    shiftWork != \"1.shift work\" & shortReturn != \"1.short return\" ~ \"0.day work\", \n  )) \n\n코드를 간단히 하기 위해 dat1을 저장하겠습니다.\n\nsaveRDS(dat1, \"data/kwcsData1.rds\")\n\n\n\n7.1.2 함수를 source file 로 저장하기\n이전에 만들었던 함수 kwcsTabf.R 이라는 파일로 저장하겠습니다.  이전에 만들었던 함수는 kwcs table 1 함수 만들기에 있습니다. 그 함수를 source 파일로 저장하겠습니다.\n\n\n\nsource file 사용\n\n함수를 R script로 저장 (“source/kwcsTabf.R”)\nsource file 불러오기 (source(“source/kwcsTabf.R”))\n함수 사용하기.\n\n\n\nsource(\"source/kwcsTabf.R\")\n\n\nrm(list=ls())\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif(!require(\"htmlTable\")) install.packages(\"htmlTable\")\nif(!require(\"haven\")) install.packages(\"haven\")\nif(!require(\"broom\")) install.packages(\"broom\")\nsource(\"source/kwcsTabf.R\")\ndat1 = readRDS(\"data/kwcsData1.rds\")\n\n층화변수, 명목변수, 연속변수를 구성하여 함수를 실행해 보겠습니다.\n\n## Variables selection\nstratas  = c(\"sleepgp\")\ncatVars = c(\n  # interesting\n  #\"wbalancegp\",\n  \"wwa1gp\", \"wwa2gp\",\"wwa3gp\",\"wwa4gp\",\"wwa5gp\",\n  # confounder\n  #\"whgp\", \n  \"shortReturn\",\"shiftWork\" , \"njob\", \n  # demograhpics\n  \"sexgp\", \"agegp\", \n  \"edugp\", \"empgp\" #, backpain\" \n)\nconVars = c(\"AGE\",\"satisfaction\")\n\ntab1 = kwcsTabf(dat1=dat1, stratas = stratas, catVars = catVars, conVars = conVars)\ntab1 %>% \n  setNames(c(\"\", \"\", \"None\", \"Disturbance\", \"P value\")) %>%\n  htmlTable(\n    cgroup = c(\"\",  \"Sleep disturbance\", \"\"), \n    n.cgroup = c(2, 2, 1), \n    tfoot = \"P value calculated by Chisq-Test and T-Test\", \n    rnames = FALSE, \n    caption = \"Basic Characteristics according to Sleep disturbance\"\n  ) \n\n\n\n\n\nBasic Characteristics according to Sleep disturbance\n\n \nSleep disturbance \n\n\n\n\n \n \nNone\nDisturbance \n \nP value\n\n\n\n\nwwa1gp\nNever \n \n12222 (94.7%)\n684 (5.3%) \n \n<0.001\n\n\n\nRarely \n \n12316 (94.5%)\n714 (5.5%) \n \n\n\n\n\nSometimes \n \n9112 (90.3%)\n981 (9.7%) \n \n\n\n\n\nOften \n \n3456 (82.8%)\n717 (17.2%) \n \n\n\n\n\nAlways \n \n634 (70.0%)\n272 (30.0%) \n \n\n\n\nwwa2gp\nNever \n \n12432 (95.4%)\n597 (4.6%) \n \n<0.001\n\n\n\nRarely \n \n13682 (94.1%)\n863 (5.9%) \n \n\n\n\n\nSometimes \n \n8882 (89.2%)\n1072 (10.8%) \n \n\n\n\n\nOften \n \n2460 (79.4%)\n638 (20.6%) \n \n\n\n\n\nAlways \n \n284 (58.9%)\n198 (41.1%) \n \n\n\n\nwwa3gp\nNever \n \n13472 (95.2%)\n682 (4.8%) \n \n<0.001\n\n\n\nRarely \n \n13938 (93.1%)\n1040 (6.9%) \n \n\n\n\n\nSometimes \n \n7749 (89.9%)\n868 (10.1%) \n \n\n\n\n\nOften \n \n2314 (79.5%)\n597 (20.5%) \n \n\n\n\n\nAlways \n \n267 (59.6%)\n181 (40.4%) \n \n\n\n\nwwa4gp\nNever \n \n18708 (94.1%)\n1169 (5.9%) \n \n<0.001\n\n\n\nRarely \n \n14799 (91.6%)\n1362 (8.4%) \n \n\n\n\n\nSometimes \n \n3348 (85.0%)\n592 (15.0%) \n \n\n\n\n\nOften \n \n805 (80.7%)\n193 (19.3%) \n \n\n\n\n\nAlways \n \n80 (60.6%)\n52 (39.4%) \n \n\n\n\nwwa5gp\nNever \n \n19061 (93.9%)\n1245 (6.1%) \n \n<0.001\n\n\n\nRarely \n \n14770 (91.6%)\n1349 (8.4%) \n \n\n\n\n\nSometimes \n \n3180 (85.3%)\n550 (14.7%) \n \n\n\n\n\nOften \n \n682 (79.8%)\n173 (20.2%) \n \n\n\n\n\nAlways \n \n47 (48.0%)\n51 (52.0%) \n \n\n\n\nshortReturn\nnon short return \n \n36183 (92.5%)\n2927 (7.5%) \n \n<0.001\n\n\n\nshort return \n \n1557 (77.9%)\n441 (22.1%) \n \n\n\n\nshiftWork\nnon shift work \n \n35056 (91.9%)\n3073 (8.1%) \n \n<0.001\n\n\n\nshift work \n \n2684 (90.1%)\n295 (9.9%) \n \n\n\n\nnjob\none-job \n \n37471 (91.9%)\n3317 (8.1%) \n \n<0.001\n\n\n\nnjob \n \n269 (84.1%)\n51 (15.9%) \n \n\n\n\nsexgp\nMen \n \n17892 (93.1%)\n1327 (6.9%) \n \n<0.001\n\n\n\nWomen \n \n19848 (90.7%)\n2041 (9.3%) \n \n\n\n\nagegp\n<25 \n \n1359 (96.6%)\n48 (3.4%) \n \n<0.001\n\n\n\n<30 \n \n2697 (94.3%)\n163 (5.7%) \n \n\n\n\n\n<35 \n \n3308 (93.6%)\n225 (6.4%) \n \n\n\n\n\n<40 \n \n3995 (92.3%)\n334 (7.7%) \n \n\n\n\n\n<45 \n \n4414 (92.2%)\n372 (7.8%) \n \n\n\n\n\n<50 \n \n4934 (92.7%)\n388 (7.3%) \n \n\n\n\n\n<55 \n \n5300 (91.9%)\n465 (8.1%) \n \n\n\n\n\n<60 \n \n5099 (90.0%)\n566 (10.0%) \n \n\n\n\n\n≥60 \n \n6634 (89.2%)\n807 (10.8%) \n \n\n\n\nedugp\nuniversity or more \n \n19597 (92.9%)\n1502 (7.1%) \n \n<0.001\n\n\n\nhigh school \n \n14943 (91.9%)\n1318 (8.1%) \n \n\n\n\n\nmiddle school or below \n \n3200 (85.4%)\n548 (14.6%) \n \n\n\n\nempgp\npaid-worker \n \n25786 (92.4%)\n2122 (7.6%) \n \n<0.001\n\n\n\nemployer/self-employer \n \n2539 (91.7%)\n229 (8.3%) \n \n\n\n\n\nown-account worker \n \n8359 (90.5%)\n880 (9.5%) \n \n\n\n\n\nunpaind family work \n \n1056 (88.5%)\n137 (11.5%) \n \n\n\n\nAGE\n \n \n46.8±12.4\n49.7±11.9 \n \n<0.001\n\n\nsatisfaction\n \n \n2.1±0.5\n2.4±0.6 \n \n<0.001\n\n\n\nP value calculated by Chisq-Test and T-Test"
  },
  {
    "objectID": "248_datamanipulation_for_table_3.html#logistic-regression-table",
    "href": "248_datamanipulation_for_table_3.html#logistic-regression-table",
    "title": "7  보건학표_3",
    "section": "7.2 Logistic Regression Table",
    "text": "7.2 Logistic Regression Table\n일과 삶의 균형이 수면장애와 관련이 있는지 Logistic regression 을 수행해보고 이를 표로 만들어 보겠습니다. \nR 로 로지스틱회귀분석을 수행하는 것은, 3가지 파트로 구성됩니다.\n\nLogistic Regression with R\n\ndata\nfamily\nmodel formula\n\n\n이때 family는 “binomial”로 formula에서 종속변수의 값을 지정해 주고, ~ 이후에 보정변수를 +로 넣는 방법입니다. 아래의 예시를 보겠습니다.\n\nmod1 = dat1 %>% \n  glm(data=.,              # data 는 . 을 통해 상속 받고, \n      family=\"binomial\",   # binomial로 구성\n      formula = sleepgp == \"1.sleep disturbance\"  # 모형 설정\n                ~ wwa1gp)\nsummary(mod1) # 모형 결과 정리\n\n\nCall:\nglm(formula = sleepgp == \"1.sleep disturbance\" ~ wwa1gp, family = \"binomial\", \n    data = .)\n\nDeviance Residuals: \n    Min       1Q   Median       3Q      Max  \n-0.8450  -0.4522  -0.3357  -0.3300   2.4238  \n\nCoefficients:\n                  Estimate Std. Error z value Pr(>|z|)    \n(Intercept)       -2.88303    0.03929 -73.378   <2e-16 ***\nwwa1gp1.Rarely     0.03526    0.05500   0.641    0.521    \nwwa1gp2.Sometimes  0.65426    0.05170  12.655   <2e-16 ***\nwwa1gp3.Often      1.31024    0.05681  23.062   <2e-16 ***\nwwa1gp4.Always     2.03679    0.08245  24.704   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 23305  on 41107  degrees of freedom\nResidual deviance: 22258  on 41103  degrees of freedom\nAIC: 22268\n\nNumber of Fisher Scoring iterations: 5\n\n\n우선 summary결과는 어떤 모델을 사용했는지 보여줍니다. 여기서 표를 만드는 이 수업의 목적에 가장 필요한 것은 Coefficients에 있습니다.  각 변수에 대해서 Estimation에 logistic regression coefficients 값을 보여주고 있습니다. 이 값을 exp(.) 한 값이 Odds Ratio 가 될 것입니다. 우리가 0.Never를 기준으로 하여 값을 산출한 것이고, 이 값은 summary에 표시되어 있지 않습니다.  그럼 coefficients 값을 가져오고, 여기에 exp(.)을 해서 odds ratio 값을 얻어 보겠습니다. 95% 신뢰구간은 confint.default(model)을 이용해서 구할 수 있습니다. p value 값도 가져오겠습니다.\n\nmod1$coefficients %>% exp(.)\n\n      (Intercept)    wwa1gp1.Rarely wwa1gp2.Sometimes     wwa1gp3.Often \n       0.05596465        1.03589255        1.92371829        3.70707693 \n   wwa1gp4.Always \n       7.66594719 \n\nconfint.default(mod1) %>% exp(.)\n\n                       2.5 %     97.5 %\n(Intercept)       0.05181673 0.06044461\nwwa1gp1.Rarely    0.93002700 1.15380884\nwwa1gp2.Sometimes 1.73834069 2.12886464\nwwa1gp3.Often     3.31643846 4.14372813\nwwa1gp4.Always    6.52209339 9.01041165\n\nmod1 %>% tidy() %>% select(term, p.value) # p value\n\n# A tibble: 5 × 2\n  term                p.value\n  <chr>                 <dbl>\n1 (Intercept)       0        \n2 wwa1gp1.Rarely    5.21e-  1\n3 wwa1gp2.Sometimes 1.05e- 36\n4 wwa1gp3.Often     1.11e-117\n5 wwa1gp4.Always    9.62e-135\n\n\n각각을 엑셀등에 붙여 넣기 하여 표를 만들면 됩니다.\n\n7.2.1 로지스틱회귀분석 표 함수 1\n반복해서 만드는 것도 좋지만, 함수를 만들어 사용하는 것이 편리할 때도 있습니다. 만약 여러 데이터를 탐색적으로 분석할 때, 어떠한 변수가 유의한지 반복적으로 보고서를 만들때, 실수와 시간을 줄이려면 함수를 만들 필요가 있습니다.  앞서서 만들 Odds Ratio, 95% CI, p value 를 합쳐 보겠습니다. 이것을 합치면, 우리가 원하는 표의 기본이 형성되었습니다.\n\ncbind(mod1$coefficients%>% exp(), confint.default(mod1)%>% exp(), mod1 %>% tidy() %>% select(p.value)) \n\n                  mod1$coefficients %>% exp()      2.5 %     97.5 %\n(Intercept)                        0.05596465 0.05181673 0.06044461\nwwa1gp1.Rarely                     1.03589255 0.93002700 1.15380884\nwwa1gp2.Sometimes                  1.92371829 1.73834069 2.12886464\nwwa1gp3.Often                      3.70707693 3.31643846 4.14372813\nwwa1gp4.Always                     7.66594719 6.52209339 9.01041165\n                        p.value\n(Intercept)        0.000000e+00\nwwa1gp1.Rarely     5.214505e-01\nwwa1gp2.Sometimes  1.048593e-36\nwwa1gp3.Often     1.108932e-117\nwwa1gp4.Always    9.619530e-135\n\n\n좀 코드가 길어보이니 함수를 만들어 보겠습니다. 이름을 mod summry function 을 줄여 modsmryf 으로 하겠습니다.\n\nmodsmryf=function(mod) {\n  cbind(mod$coefficients %>% exp(.), confint.default(mod)%>% exp(.), mod %>% tidy() %>% select(p.value))}\n\n\nmodsmryf(mod1)\n\n                  mod$coefficients %>% exp(.)      2.5 %     97.5 %\n(Intercept)                        0.05596465 0.05181673 0.06044461\nwwa1gp1.Rarely                     1.03589255 0.93002700 1.15380884\nwwa1gp2.Sometimes                  1.92371829 1.73834069 2.12886464\nwwa1gp3.Often                      3.70707693 3.31643846 4.14372813\nwwa1gp4.Always                     7.66594719 6.52209339 9.01041165\n                        p.value\n(Intercept)        0.000000e+00\nwwa1gp1.Rarely     5.214505e-01\nwwa1gp2.Sometimes  1.048593e-36\nwwa1gp3.Often     1.108932e-117\nwwa1gp4.Always    9.619530e-135\n\n\n이번에는 두번째 모델을 만들어 보겠습니다. 성별과 연령을 보정한 모델입니다. 이 모델도 앞서 만든 modsmryf 함수로 잘 표현될 수 있는 지 확인해 보겠습니다.\n\nmod2 = dat1 %>%\n  glm(data=., \n      family=\"binomial\", \n      formula = sleepgp == \"1.sleep disturbance\" \n                ~ wwa1gp + \n                  AGE + sexgp +satisfaction\n        )\nmodsmryf(mod2)\n\n                  mod$coefficients %>% exp(.)       2.5 %      97.5 %\n(Intercept)                       0.003804483 0.003053111 0.004740768\nwwa1gp1.Rarely                    1.001621017 0.898377792 1.116729143\nwwa1gp2.Sometimes                 1.833495422 1.654865417 2.031407164\nwwa1gp3.Often                     3.420379336 3.053476051 3.831369432\nwwa1gp4.Always                    6.907050334 5.845309980 8.161644888\nAGE                               1.013712744 1.010590103 1.016845033\nsexgpWomen                        1.532246823 1.421896138 1.651161618\nsatisfaction                      2.288037866 2.145736519 2.439776380\n                        p.value\n(Intercept)        0.000000e+00\nwwa1gp1.Rarely     9.767193e-01\nwwa1gp2.Sometimes  4.552779e-31\nwwa1gp3.Often     3.967119e-100\nwwa1gp4.Always    5.123559e-114\nAGE                5.044326e-18\nsexgpWomen         4.563279e-29\nsatisfaction      7.930347e-141\n\n\n이번엔 세번째는 shiftwork, njob을 보정해 보겠습니다. model 3를 의미하는 mod3로 저장하고 만들어 보겠습니다.\n\nmod3 = dat1 %>%\n  glm(data=., \n      family=\"binomial\", \n      formula = sleepgp == \"1.sleep disturbance\" \n                ~ wwa1gp + \n                  AGE + sexgp +satisfaction+\n                  shiftWork + njob\n        )\nmodsmryf(mod3)\n\n                      mod$coefficients %>% exp(.)       2.5 %      97.5 %\n(Intercept)                           0.003567629 0.002858947 0.004451981\nwwa1gp1.Rarely                        1.012175630 0.907728389 1.128641032\nwwa1gp2.Sometimes                     1.877721635 1.694025217 2.081337693\nwwa1gp3.Often                         3.491071324 3.114898897 3.912672415\nwwa1gp4.Always                        7.046449183 5.959274630 8.331961382\nAGE                                   1.014223241 1.011097186 1.017358962\nsexgpWomen                            1.542246850 1.431082137 1.662046702\nsatisfaction                          2.272860173 2.131360030 2.423754454\nshiftWork1.shift work                 1.510263841 1.324733670 1.721777683\nnjob1.njob                            1.588563409 1.150750845 2.192945340\n                            p.value\n(Intercept)            0.000000e+00\nwwa1gp1.Rarely         8.275949e-01\nwwa1gp2.Sometimes      3.779474e-33\nwwa1gp3.Often         1.843134e-102\nwwa1gp4.Always        1.977308e-115\nAGE                    3.049355e-19\nsexgpWomen             7.361792e-30\nsatisfaction          2.554569e-138\nshiftWork1.shift work  7.049028e-10\nnjob1.njob             4.899856e-03\n\n\n이제 모델1, 2, 3가 만들어 졌습니다. 이걸 반복해서 만들고, 엑셀등에 붙여 넣기 하여 표를 만들면 됩니다.\n\n\n7.2.2 로지스틱 회귀분석 표 2\n앞선 함수를 조금더 업데이트 하겠습니다. 보통 보기편한 방식은 OR (95%CI) 로 표시하는 것입니다. 또한, 기준이되는 변수 값에는 “1.00 (reference)”로 표시하는 것이 필요합니다. 그럴려면, 사용된 변수의 모든 변수값의 종류는 표에 나타내어야 하는 basic matrix 가 필요합니다. 따라서 \n\n로지스틱 회귀분석 함수\n\n사용된 변수의 Basic Matrix 만들기\n기준된 변수 값에는 “1.00 (reference)” 값 주기\n나머진 변수 에는 OR (95% CI) 나타내기\n\n\n를 수행하면 됩니다.\n\nbasic matrix\n\n명목변수(factor 등)과 연속변수를 나누어 basic matrix 를 만들겠습니다. 이는 logistic regression model 의 xlevels 와 model에 있습니다.\n\nmod3$xlevels \n\n$wwa1gp\n[1] \"0.Never\"     \"1.Rarely\"    \"2.Sometimes\" \"3.Often\"     \"4.Always\"   \n\n$sexgp\n[1] \"Men\"   \"Women\"\n\n$shiftWork\n[1] \"0.non shift work\" \"1.shift work\"    \n\n$njob\n[1] \"0.one-job\" \"1.njob\"   \n\nmod3$model %>% \n  slice(1:2) %>% \n  select(where(is.numeric))\n\n  AGE satisfaction\n1  54            2\n2  64            2\n\n\n이것을 data.frame 형식으로 만들겠습니다. list 형식으로, list 뒤에 [1] 을 통해 이름을, [[1]]을 통해 list 값을 가져오겠습니다.\n\nt1 = mod3$xlevel\ntibble(names(t1)[1], values=t1[[1]])\n\n# A tibble: 5 × 2\n  `names(t1)[1]` values     \n  <chr>          <chr>      \n1 wwa1gp         0.Never    \n2 wwa1gp         1.Rarely   \n3 wwa1gp         2.Sometimes\n4 wwa1gp         3.Often    \n5 wwa1gp         4.Always   \n\n\n이것을 함수로 나타내면, 아래와 같고, 이를 반복하면 다음과 같습니다 . 그런데 몇번 반복해야 할 까요?\n\ntest = function(x){\n  tibble(names(t1)[x], values=t1[[x]])\n}\nfor (i in 1:4){\nprint(test(i))\n}\n\n# A tibble: 5 × 2\n  `names(t1)[x]` values     \n  <chr>          <chr>      \n1 wwa1gp         0.Never    \n2 wwa1gp         1.Rarely   \n3 wwa1gp         2.Sometimes\n4 wwa1gp         3.Often    \n5 wwa1gp         4.Always   \n# A tibble: 2 × 2\n  `names(t1)[x]` values\n  <chr>          <chr> \n1 sexgp          Men   \n2 sexgp          Women \n# A tibble: 2 × 2\n  `names(t1)[x]` values          \n  <chr>          <chr>           \n1 shiftWork      0.non shift work\n2 shiftWork      1.shift work    \n# A tibble: 2 × 2\n  `names(t1)[x]` values   \n  <chr>          <chr>    \n1 njob           0.one-job\n2 njob           1.njob   \n\n\n몇 번 반복할지는 변수의 갯수가 몇개인지에 따라 달라집니다. 이를 통해 lapply, map을 이용해서 수행하겠습니다.\n\nlength(mod3$xlevels) # 4개의 list가 있음을 알수 있습니다. \n\n[1] 4\n\nlapply(1:4, test)\n\n[[1]]\n# A tibble: 5 × 2\n  `names(t1)[x]` values     \n  <chr>          <chr>      \n1 wwa1gp         0.Never    \n2 wwa1gp         1.Rarely   \n3 wwa1gp         2.Sometimes\n4 wwa1gp         3.Often    \n5 wwa1gp         4.Always   \n\n[[2]]\n# A tibble: 2 × 2\n  `names(t1)[x]` values\n  <chr>          <chr> \n1 sexgp          Men   \n2 sexgp          Women \n\n[[3]]\n# A tibble: 2 × 2\n  `names(t1)[x]` values          \n  <chr>          <chr>           \n1 shiftWork      0.non shift work\n2 shiftWork      1.shift work    \n\n[[4]]\n# A tibble: 2 × 2\n  `names(t1)[x]` values   \n  <chr>          <chr>    \n1 njob           0.one-job\n2 njob           1.njob   \n\nmap(1:4, test)\n\n[[1]]\n# A tibble: 5 × 2\n  `names(t1)[x]` values     \n  <chr>          <chr>      \n1 wwa1gp         0.Never    \n2 wwa1gp         1.Rarely   \n3 wwa1gp         2.Sometimes\n4 wwa1gp         3.Often    \n5 wwa1gp         4.Always   \n\n[[2]]\n# A tibble: 2 × 2\n  `names(t1)[x]` values\n  <chr>          <chr> \n1 sexgp          Men   \n2 sexgp          Women \n\n[[3]]\n# A tibble: 2 × 2\n  `names(t1)[x]` values          \n  <chr>          <chr>           \n1 shiftWork      0.non shift work\n2 shiftWork      1.shift work    \n\n[[4]]\n# A tibble: 2 × 2\n  `names(t1)[x]` values   \n  <chr>          <chr>    \n1 njob           0.one-job\n2 njob           1.njob   \n\nmap(1:length(mod3$xlevels), test)\n\n[[1]]\n# A tibble: 5 × 2\n  `names(t1)[x]` values     \n  <chr>          <chr>      \n1 wwa1gp         0.Never    \n2 wwa1gp         1.Rarely   \n3 wwa1gp         2.Sometimes\n4 wwa1gp         3.Often    \n5 wwa1gp         4.Always   \n\n[[2]]\n# A tibble: 2 × 2\n  `names(t1)[x]` values\n  <chr>          <chr> \n1 sexgp          Men   \n2 sexgp          Women \n\n[[3]]\n# A tibble: 2 × 2\n  `names(t1)[x]` values          \n  <chr>          <chr>           \n1 shiftWork      0.non shift work\n2 shiftWork      1.shift work    \n\n[[4]]\n# A tibble: 2 × 2\n  `names(t1)[x]` values   \n  <chr>          <chr>    \n1 njob           0.one-job\n2 njob           1.njob   \n\n\n이것을 통해 basic matrix를 만듭니다.\n\nt1 = mod3$xlevels\nbm1 = map(1:length(t1), function(x){\n  tibble(variables = names(t1)[x], \n         values = t1[[x]])\n}) %>% do.call(rbind, .)\nbm2 = mod3$model %>% \n  slice(1:2) %>% \n  select(where(is.numeric)) %>% \n  pivot_longer(-c()) %>% \n  select(variables = name) %>%\n  mutate(values =\"\") %>% unique()\nbm0 =rbind(bm1, bm2) %>%\n  mutate(keys=paste0(variables, values))\nbm0 %>% htmlTable()\n\n\n\n\n\nvariables\nvalues\nkeys\n\n\n\n\n1\nwwa1gp\n0.Never\nwwa1gp0.Never\n\n\n2\nwwa1gp\n1.Rarely\nwwa1gp1.Rarely\n\n\n3\nwwa1gp\n2.Sometimes\nwwa1gp2.Sometimes\n\n\n4\nwwa1gp\n3.Often\nwwa1gp3.Often\n\n\n5\nwwa1gp\n4.Always\nwwa1gp4.Always\n\n\n6\nsexgp\nMen\nsexgpMen\n\n\n7\nsexgp\nWomen\nsexgpWomen\n\n\n8\nshiftWork\n0.non shift work\nshiftWork0.non shift work\n\n\n9\nshiftWork\n1.shift work\nshiftWork1.shift work\n\n\n10\nnjob\n0.one-job\nnjob0.one-job\n\n\n11\nnjob\n1.njob\nnjob1.njob\n\n\n12\nAGE\n\nAGE\n\n\n13\nsatisfaction\n\nsatisfaction\n\n\n\n\n\nodds ratio 를 정리해 보겠습니다.\n\nmm = modsmryf(mod3)\nmm1 = mm%>% \n  data.frame() %>% \n  setNames(c(\"or\", \"ll\", \"ul\", \"pvalue\")) %>%\n  mutate(keys=rownames(mm)) \n\n이상의 것을 합쳐서 하나의 테이블로 만듭니다.\n\nbm0 %>%\n  left_join(mm1, by=c(\"keys\")) %>%\n  mutate(OR95CI = case_when(\n    is.na(or) ~ \"1.00 (reference)\", \n    TRUE ~ sprintf(\"%.2f (%.2f-%.2f)\", round(or, 2), round(ll, 2), round(ul, 2))\n  )) %>%\n  select(variables, values, OR95CI, pvalue) %>%\n  mutate(pvalue = ifelse(pvalue <0.001, \"<0.001\", sprintf(\"%.3f\", pvalue))) %>%\n  htmlTable()\n\n\n\n\n\nvariables\nvalues\nOR95CI\npvalue\n\n\n\n\n1\nwwa1gp\n0.Never\n1.00 (reference)\n\n\n\n2\nwwa1gp\n1.Rarely\n1.01 (0.91-1.13)\n0.828\n\n\n3\nwwa1gp\n2.Sometimes\n1.88 (1.69-2.08)\n<0.001\n\n\n4\nwwa1gp\n3.Often\n3.49 (3.11-3.91)\n<0.001\n\n\n5\nwwa1gp\n4.Always\n7.05 (5.96-8.33)\n<0.001\n\n\n6\nsexgp\nMen\n1.00 (reference)\n\n\n\n7\nsexgp\nWomen\n1.54 (1.43-1.66)\n<0.001\n\n\n8\nshiftWork\n0.non shift work\n1.00 (reference)\n\n\n\n9\nshiftWork\n1.shift work\n1.51 (1.32-1.72)\n<0.001\n\n\n10\nnjob\n0.one-job\n1.00 (reference)\n\n\n\n11\nnjob\n1.njob\n1.59 (1.15-2.19)\n0.005\n\n\n12\nAGE\n\n1.01 (1.01-1.02)\n<0.001\n\n\n13\nsatisfaction\n\n2.27 (2.13-2.42)\n<0.001\n\n\n\n\n\n이제 됬습니다. 이것을 통해 표를 만들면 되겠습니다. 반복 작업이 필요할 수도 있으니, 함수로 만들겠습니다. 다만 회귀분석 모델이 error가 있거나 하는 상황이 있으므로, argumet 값이 missing이 아닌 경우에 함수가 실행되게 하겠습니다. 또한 xlevels가 없는 경우, numeric 함수가 없을 경우에도 작동할 수 있도록, 아래와 같이 if else 를 사용해서 함수를 만듭니다. 또한 p value가 0.05보다 작은 경우 bold 로 표시하기 위해 html 언어인 <b> ... </b> 를 사용하고, reference인 경우는 <i>...</i>를 이용해서 italic 폰트를 구성하였습니다.\n\noddf=function(a){\nif(!missing(a)){  \nmm = modsmryf(a)\nmm1 = mm%>% \n  data.frame() %>% \n  setNames(c(\"or\", \"ll\", \"ul\", \"pvalue\")) %>%\n  mutate(keys=rownames(mm)) \nif(!any(is.na(a$xlevels))){\n  t1 = a$xlevels\n  bm1 = map(1:length(t1),function(x){tibble(variables= names(t1)[x], values = t1[[x]])}) %>% do.call(rbind, .)\n} else {\n  t1 = data.frame();bm1=data.frame()\n}\nif(nrow(a$model %>% select(where(is.numeric))%>% unique()) >0){\n    bm2 = a$model %>% slice(1:2)%>%select(where(is.numeric))%>% pivot_longer(-c()) %>% select(variables = name) %>% mutate(values=\"\") %>% unique()\n} else {\n    bm2 = data.frame()  \n}\nbm0 = rbind(bm1, bm2) %>% mutate(keys= paste0(variables, values))\n\natab= bm0 %>% \n  left_join(mm1, by=c(\"keys\")) %>%\n  mutate(OR95CI = case_when(\n    is.na(or) ~ \"<i>1.00 (reference)</i>\", \n    pvalue < 0.05 ~ sprintf(\"<b>%.2f (%.2f-%.2f)</b>\", round(or, 2), round(ll, 2), round(ul, 2)), \n    TRUE ~ sprintf(\"%.2f (%.2f-%.2f)\", round(or, 2), round(ll, 2), round(ul, 2))\n  )) %>%\n  mutate(values = case_when(\n    pvalue <0.05 ~ sprintf(\"<b>%s</b>\", values), \n    TRUE ~ values\n  )) %>%\n  select(variables, values, OR95CI) \n  return(atab)\n} else {\n  atab = data.frame(\"variables\"=c(NA), \"values\"=c(NA), \"OR95CI\"=c(NA))\n  return(atab)\n}\n} %>% suppressWarnings() \n\n잘 작동하는 지 살펴 보겠습니다 .\n\noddf(mod1) %>% htmlTable()\n\n\n\n\n\nvariables\nvalues\nOR95CI\n\n\n\n\n1\nwwa1gp\n0.Never\n1.00 (reference)\n\n\n2\nwwa1gp\n1.Rarely\n1.04 (0.93-1.15)\n\n\n3\nwwa1gp\n2.Sometimes\n1.92 (1.74-2.13)\n\n\n4\nwwa1gp\n3.Often\n3.71 (3.32-4.14)\n\n\n5\nwwa1gp\n4.Always\n7.67 (6.52-9.01)\n\n\n\n\n\n\n\n7.2.3 로지스틱 회귀분석 3\n그런데 만약 model을 여러개를 한번에 나타내려면 어떻게 하면될까요? 네 반복문을 사용해서 list를 만들고, 옆으로 붙이면 됩니다. reduce해서 cbind하면됩니다. \n\n여러 모델 표 구성하기\n\n표 반복해서 만들기\nlist 횡 병합하기 (join)\n모델 갯수 만큼 모델명 만들기\n\n\n\noddsf= function(...){\n  arglist = list(...)\n    #mod_list = mget(ls()) %>%\n    #      list.filter(length(.)>1)\n  tt = map(arglist, oddf) %>%\n      reduce(full_join, by=c(\"variables\", \"values\"))\n  vl = c(length(tt)-2)\n  tt = tt %>% setNames(c(\"Variables\", \"Values\", paste0(\"Model.\", as.roman(1:vl))))\n  return(tt)\n}\n\n잘 작동하는지 보겠습니다.\n\noddsf(mod1, mod2) %>% htmlTable()\n\n\n\n\n\nVariables\nValues\nModel.I\nModel.II\n\n\n\n\n1\nwwa1gp\n0.Never\n1.00 (reference)\n1.00 (reference)\n\n\n2\nwwa1gp\n1.Rarely\n1.04 (0.93-1.15)\n1.00 (0.90-1.12)\n\n\n3\nwwa1gp\n2.Sometimes\n1.92 (1.74-2.13)\n1.83 (1.65-2.03)\n\n\n4\nwwa1gp\n3.Often\n3.71 (3.32-4.14)\n3.42 (3.05-3.83)\n\n\n5\nwwa1gp\n4.Always\n7.67 (6.52-9.01)\n6.91 (5.85-8.16)\n\n\n6\nsexgp\nMen\n\n1.00 (reference)\n\n\n7\nsexgp\nWomen\n\n1.53 (1.42-1.65)\n\n\n8\nAGE\n\n\n1.01 (1.01-1.02)\n\n\n9\nsatisfaction\n\n\n2.29 (2.15-2.44)\n\n\n\n\n\noddsf 함수 만으로는 조금 부족해 보입니다. 이제 이것을 좀더 보기 편하게 꾸며 보겠습니다. \n\n표 꾸미기\n\n표 이름 만들기\n중복 항목 지우기\nNA 값을 빈칸으로 만들기\n\n\n\noddsTabf = function(...){\n  arglist = list(...)\n  mod1 = arglist[[1]]\n  tt = map(arglist, oddf) %>%\n    reduce(full_join, by=c(\"variables\", \"values\"))\n  vl = c(length(tt)-2)\n  ys =  mod1$formula[2] %>% as.character() %>% str_replace(., \"\\\\=\\\\=\", \"being reference of\") %>%\n    str_replace_all(., '\\\\\"', \"\")\n  tt = tt %>% setNames(c(\"Variables\", \"Values\", paste0(\"Model.\", as.roman(1:vl))))\n  tt %>%  `rownames<-`(NULL) %>%\n    group_by(Variables) %>%\n    mutate(rank = row_number()) %>%\n    mutate(Variables = ifelse(rank == min(rank), Variables, \"\")) %>%\n    mutate_at(., vars(starts_with(\"Model\")), ~replace(., is.na(.), \"\")) %>%  \n    ungroup() %>% select(-rank) %>%\n    addHtmlTableStyle(align = 'll') %>%\n    htmlTable(\n      caption = sprintf(\"Table. OR(95%%CI) for %s\", ys)\n      \n    )\n  \n}\n\n잘 작동하는지 알아보겠습니다.\n\noddsTabf(mod1, mod2, mod3)\n\n\n\n\n\nTable. OR(95%CI) for sleepgp being reference of 1.sleep disturbance\n\nVariables\nValues\nModel.I\nModel.II\nModel.III\n\n\n\n\n1\nwwa1gp\n0.Never\n1.00 (reference)\n1.00 (reference)\n1.00 (reference)\n\n\n2\n\n1.Rarely\n1.04 (0.93-1.15)\n1.00 (0.90-1.12)\n1.01 (0.91-1.13)\n\n\n3\n\n2.Sometimes\n1.92 (1.74-2.13)\n1.83 (1.65-2.03)\n1.88 (1.69-2.08)\n\n\n4\n\n3.Often\n3.71 (3.32-4.14)\n3.42 (3.05-3.83)\n3.49 (3.11-3.91)\n\n\n5\n\n4.Always\n7.67 (6.52-9.01)\n6.91 (5.85-8.16)\n7.05 (5.96-8.33)\n\n\n6\nsexgp\nMen\n\n1.00 (reference)\n1.00 (reference)\n\n\n7\n\nWomen\n\n1.53 (1.42-1.65)\n1.54 (1.43-1.66)\n\n\n8\nAGE\n\n\n1.01 (1.01-1.02)\n1.01 (1.01-1.02)\n\n\n9\nsatisfaction\n\n\n2.29 (2.15-2.44)\n2.27 (2.13-2.42)\n\n\n10\nshiftWork\n0.non shift work\n\n\n1.00 (reference)\n\n\n11\n\n1.shift work\n\n\n1.51 (1.32-1.72)\n\n\n12\nnjob\n0.one-job\n\n\n1.00 (reference)\n\n\n13\n\n1.njob\n\n\n1.59 (1.15-2.19)\n\n\n\n\n\n이 것을 source 파일로 저장하겠습니다.\n\nsource(\"source/oddsTabf.R\")\n\n수고하셨습니다."
  },
  {
    "objectID": "250_smry_for_table.html#install-package-from-github",
    "href": "250_smry_for_table.html#install-package-from-github",
    "title": "8  보건학표 만들기 요약",
    "section": "8.1 install package from github",
    "text": "8.1 install package from github\ntidyvere and htmlTable, and broom 가 데이터를 변환하고 표시하는데 자주 사용됩니다. devtools 은 “github”에 있는 함수를 불러오는데 사용됩니다.  install_github 을 통해 패키지를 설치하겠습니다.\n\nrm(list=ls())\n#basic requirment\nif(!require(\"tidyverse\")) install.packages(\"tidyverse\")\nif(!require(\"htmlTable\")) install.packages(\"htmlTable\")\nif(!require(\"broom\")) install.packages(\"broom\")\nif(!require(\"labelled\")) install.packages(\"labelled\")\n# packages from github\nif(!require(\"devtools\")) install.packages(\"devtools\")\nlibrary(devtools)\ninstall_github(\"jinhaslab/tabf\", force = TRUE, quiet = TRUE)\nlibrary(tabf)"
  },
  {
    "objectID": "250_smry_for_table.html#데이터-준비",
    "href": "250_smry_for_table.html#데이터-준비",
    "title": "8  보건학표 만들기 요약",
    "section": "8.2 데이터 준비",
    "text": "8.2 데이터 준비\n데이터 표를 만드는 실습은 6차 근로환경조사 자료를 통해 실습할 것입니다.. 자료는 안전보건공단, 근로환경조사 원시자료 사이트 (http://kosha.or.kr/kosha/data/primitiveData.do) 에서 신청할 수 있습니다..\n데이터 표를 만드는 실습은 6차 근로환경조사 자료를 통해 실습할 것입니다.. 자료는 안전보건공단, 근로환경조사 원시자료 사이트 (http://kosha.or.kr/kosha/data/primitiveData.do) 에서 신청할 수 있습니다.. 데이터를 불러오겠습니다. 안전보건공단 홈페이에서 자료를 다운 받는게 원칙입니다. 다만 실습을 빠르게 진행하기 위해서, dspubs.org 페이지에 있는 파일을 이용하겠습니다.   kwcsData6th.rds   자신의 folder에 data 라는 folder가 있는지 확인하십시오. data라는 폴더에 다운로드하고, 불러오도록 하겠습니다.\n\nurl <- \"https://raw.githubusercontent.com/jinhaslab/opendata/main/kwcs/kwcsData6th.rds\"\ndownload.file(url, \"data/tutorKWCS.rds\")\nkwcs = readRDS(\"data/tutorKWCS.rds\")\n\n\n8.2.1 근로환경조사 기본 변수 생성 (선택)\ndata manipulation에서 실습한 내용을 통해 변수를 실습을 위한 변수를 생성해 보겠습니다. 이에 대한 자세한 과정은 이전 챔터에 있습니다. \nTable 1 변수 생성과정 챕터\n\n# data manip function\nLikert5f = function(x){dplyr::recode(as.numeric(x), \n         \"4.Always\",\"3.Often\",\"2.Sometimes\", \"1.Rarely\",\"0.Never\" )}\n\n# data step start ----------\n\ndat1 = kwcs %>%\n  filter(AGE <70) %>%\n  filter(AGE >18) %>%\n  # sleep --------\n  filter(!is.na(sleep1)&!is.na(sleep2)&!is.na(sleep3)) %>%\n  filter(sleep1 %in% c(1:5), \n         sleep2 %in% c(1:5), \n         sleep3 %in% c(1:5)) %>%\n  mutate(sleep1in = 5-sleep1, \n         sleep2in = 5-sleep2,\n         sleep3in = 5-sleep3\n         ) %>%\n  mutate(sleepgp = case_when(\n    sleep1in + sleep2in+ sleep3in >=6 ~ \"1.sleep disturbance\", \n    TRUE ~ \"0.non distrubance\"\n  )) %>%\n  # work live balances -------------\n  filter(!is.na(wbalance), !is.na(wwa1), !is.na(wwa2), !is.na(wwa3), !is.na(wwa4), !is.na(wwa5)) %>%\n  filter(!is.na(wbalance)) %>%\n  mutate(wbalancegp = case_when(\n    wbalance %in% c(1, 2) ~ \"0.balance\", \n    TRUE ~ \"1.non balance\"\n  )) %>%\n  mutate(wwa1gp=Likert5f(wwa1), wwa2gp=Likert5f(wwa2),  wwa3gp=Likert5f(wwa3), \n         wwa4gp=Likert5f(wwa4), wwa5gp=Likert5f(wwa5), \n         ) %>%\n  # job and sex, agegp  ----------\n  filter(!is.na(job1))%>%\n  filter(job1 %in% c(1, 2, 3)) %>%\n  mutate(sexgp = case_when(\n    TSEX ==1 ~ \"Men\", \n    TRUE ~ \"Women\"\n  )) %>%\n  mutate(agegp = case_when(AGE <25 ~ \"<25\", AGE <30 ~ \"<30\",  AGE <35 ~ \"<35\", \n    AGE <40 ~ \"<40\", AGE <45 ~ \"<45\", AGE <50 ~ \"<50\",AGE <55 ~ \"<55\", AGE <60 ~ \"<60\",\n    TRUE ~ \"\\u226560\" # 나머지는 모두 >65 (\\u2265는 크거나 같다는 symbol)\n  )) %>%\n  filter(!is.na(edu)) %>% filter(edu %in% c(1:7)) %>%\n  mutate(edugp = case_when(\n    edu %in% c(1:3) ~    \"2.middle school or below\",\n    edu %in% c(4  ) ~    \"1.high school\",\n    edu %in% c(5:7)   ~  \"0.university or more\"\n  )) %>%\n  mutate(njob=case_when(\n    job1 %in% c(2, 3) ~ \"1.njob\", \n    TRUE ~ \"0.one-job\")) %>%\n  # pains back -----------\n  mutate(backpain= case_when(\n    heal_prob1==1 ~ \"pain\", \n    TRUE ~ \"no-pain\")) %>%\n  # emp_type,working hours, shiftwork, work life balance -------\n  filter(!is.na(emp_type)) %>%\n  filter(emp_type %in% c(1:4)) %>%\n  mutate(empgp = case_when(\n    emp_type ==1 ~ \"2.own-account worker\", \n    emp_type ==2 ~ \"1.employer/self-employer\", \n    emp_type ==3 ~ \"0.paid-worker\", \n    emp_type ==4 ~ \"3.unpaind family work\"\n  )) %>%\n  filter(!is.na(wtime_week)) %>%\n  mutate(whgp=case_when(\n    wtime_week < 35 ~ \"<35\", \n    wtime_week < 40 ~ \"<40\", \n    wtime_week < 52 ~ \"<52\", \n    wtime_week < 60 ~ \"<60\", \n    TRUE ~ \"\\u226560\", \n  )) %>%\n  filter(!is.na(wtime_length5)) %>%\n  filter(wtime_length5 %in% c(1, 2)) %>%\n  mutate(shiftWork = case_when(\n    wtime_length5 ==1 ~ \"1.shift work\", \n    TRUE ~ \"0.non shift work\"\n  )) %>%\n  filter(!is.na(wtime_resilience)) %>%\n  mutate(shortReturn = case_when(\n    wtime_resilience ==1 ~ \"1.short return\", \n    TRUE ~ \"0.non short return\"\n  )) %>%\n  filter(!is.na(satisfaction)) %>%\n  filter(satisfaction %in% c(1:4)) %>%\n  mutate(satisInv = 5-satisfaction) %>%\n  mutate(shiftShort=case_when(\n    shiftWork == \"1.shift work\" & shortReturn == \"1.short return\" ~ \"3.shift work with short return\", \n    shiftWork == \"1.shift work\" & shortReturn != \"1.short return\" ~ \"2.shift work\", \n    shiftWork != \"1.shift work\" & shortReturn == \"1.short return\" ~ \"1.day work with short return\", \n    shiftWork != \"1.shift work\" & shortReturn != \"1.short return\" ~ \"0.day work\", \n  )) \n\n코드를 간단히 하기 위해 dat1을 저장하겠습니다.\n\nsaveRDS(dat1, \"data/kwcsData1.rds\")\n\n\ndat1 = readRDS(\"data/kwcsData1.rds\")"
  },
  {
    "objectID": "250_smry_for_table.html#변수-선정-그리고-표-1",
    "href": "250_smry_for_table.html#변수-선정-그리고-표-1",
    "title": "8  보건학표 만들기 요약",
    "section": "8.3 변수 선정 그리고 표 1",
    "text": "8.3 변수 선정 그리고 표 1\n변수는 종속변수, 독립변수로 나눌수 있고, 독립변수는 성격에 따라 연속변수와 명목변수로 나눌 수 있습니다. 그렇게 구별해 보겠습니다.\n\nstratas  = c(\"sleepgp\")\ncatVars = c(\"wwa1gp\", \"shortReturn\",\"shiftWork\" , \"njob\", \"sexgp\",  \"edugp\", \"empgp\")\nconVars = c(\"AGE\",\"satisfaction\")\n\ntabf() 은 우리가 설정한 것에 따라 표1을 만들어 줍니다. htmlTable()은 붙여 넣기 좋게 화면에 출력해 줍니다.\n\ntab1 = tabf(dat1=dat1, stratas = stratas, catVars = catVars, conVars = conVars)\ntab1\n\n# A tibble: 22 × 5\n   variables      values       `0.non distrubance` `1.sleep disturbance` p.value\n   <chr>          <chr>        <chr>               <chr>                 <chr>  \n 1 \"AGE\"          \"\"           46.8±12.4           49.7±11.9             \"<0.00…\n 2 \"wwa1gp\"       \"Never\"      12222 (94.7%)       684 (5.3%)            \"<0.00…\n 3 \"\"             \"Rarely\"     12316 (94.5%)       714 (5.5%)            \"\"     \n 4 \"\"             \"Sometimes\"  9112 (90.3%)        981 (9.7%)            \"\"     \n 5 \"\"             \"Often\"      3456 (82.8%)        717 (17.2%)           \"\"     \n 6 \"\"             \"Always\"     634 (70.0%)         272 (30.0%)           \"\"     \n 7 \"satisfaction\" \"\"           2.1±0.5             2.4±0.6               \"<0.00…\n 8 \"shortReturn\"  \"non short … 36183 (92.5%)       2927 (7.5%)           \"<0.00…\n 9 \"\"             \"short retu… 1557 (77.9%)        441 (22.1%)           \"\"     \n10 \"shiftWork\"    \"non shift … 35056 (91.9%)       3073 (8.1%)           \"<0.00…\n# ℹ 12 more rows\n\n\nhtmlTable()을 이용해서 보기 좋게 만들어 보겠습니다.\n\ntab1 %>% \n  setNames(c(\"\", \"\", \"None\", \"Disturbance\", \"P value\")) %>%\n  htmlTable(\n    cgroup = c(\"\",  \"Sleep disturbance\", \"\"), \n    n.cgroup = c(2, 2, 1), \n    tfoot = \"P value calculated by Chisq-Test and T-Test\", \n    rnames = FALSE, \n    caption = \"Basic Characteristics according to Sleep disturbance\"\n  ) \n\n\n\n\n\nBasic Characteristics according to Sleep disturbance\n\n \nSleep disturbance \n\n\n\n\n \n \nNone\nDisturbance \n \nP value\n\n\n\n\nAGE\n \n \n46.8±12.4\n49.7±11.9 \n \n<0.001\n\n\nwwa1gp\nNever \n \n12222 (94.7%)\n684 (5.3%) \n \n<0.001\n\n\n\nRarely \n \n12316 (94.5%)\n714 (5.5%) \n \n\n\n\n\nSometimes \n \n9112 (90.3%)\n981 (9.7%) \n \n\n\n\n\nOften \n \n3456 (82.8%)\n717 (17.2%) \n \n\n\n\n\nAlways \n \n634 (70.0%)\n272 (30.0%) \n \n\n\n\nsatisfaction\n \n \n2.1±0.5\n2.4±0.6 \n \n<0.001\n\n\nshortReturn\nnon short return \n \n36183 (92.5%)\n2927 (7.5%) \n \n<0.001\n\n\n\nshort return \n \n1557 (77.9%)\n441 (22.1%) \n \n\n\n\nshiftWork\nnon shift work \n \n35056 (91.9%)\n3073 (8.1%) \n \n<0.001\n\n\n\nshift work \n \n2684 (90.1%)\n295 (9.9%) \n \n\n\n\nnjob\none-job \n \n37471 (91.9%)\n3317 (8.1%) \n \n<0.001\n\n\n\nnjob \n \n269 (84.1%)\n51 (15.9%) \n \n\n\n\nsexgp\nMen \n \n17892 (93.1%)\n1327 (6.9%) \n \n<0.001\n\n\n\nWomen \n \n19848 (90.7%)\n2041 (9.3%) \n \n\n\n\nedugp\nuniversity or more \n \n19597 (92.9%)\n1502 (7.1%) \n \n<0.001\n\n\n\nhigh school \n \n14943 (91.9%)\n1318 (8.1%) \n \n\n\n\n\nmiddle school or below \n \n3200 (85.4%)\n548 (14.6%) \n \n\n\n\nempgp\npaid-worker \n \n25786 (92.4%)\n2122 (7.6%) \n \n<0.001\n\n\n\nemployer/self-employer \n \n2539 (91.7%)\n229 (8.3%) \n \n\n\n\n\nown-account worker \n \n8359 (90.5%)\n880 (9.5%) \n \n\n\n\n\nunpaind family work \n \n1056 (88.5%)\n137 (11.5%) \n \n\n\n\n\nP value calculated by Chisq-Test and T-Test"
  },
  {
    "objectID": "250_smry_for_table.html#로지스틱-회귀-분석",
    "href": "250_smry_for_table.html#로지스틱-회귀-분석",
    "title": "8  보건학표 만들기 요약",
    "section": "8.4 로지스틱 회귀 분석",
    "text": "8.4 로지스틱 회귀 분석\n로지스틱 회귀 분석은 오즈비와 95% 신뢰구간을 구하는데 사용합니다. 여기서는 수면장애의 오즈를 “일을 하지 않을 때에도 걱정하는” 정도에 따라 분석해 보겠습니다. 첫번째 모델을 걱정 변수만 넣어서, 두번째 모델은 연령, 성별, 근무 만족도를 넣어서, 3번째는 교대 근무와, n-job 여부를 넣어서 분석하겠습니다.\n\nmod1 = dat1 %>%\n  glm(data=.,family=\"binomial\",formula = sleepgp == \"1.sleep disturbance\"  \n      ~ wwa1gp)\nmod2 = dat1 %>%\n  glm(data=.,family=\"binomial\",formula = sleepgp == \"1.sleep disturbance\"\n      ~ wwa1gp + AGE + sexgp +satisfaction)\nmod3 = dat1 %>%\n  glm(data=.,family=\"binomial\",formula = sleepgp == \"1.sleep disturbance\"\n      ~ wwa1gp + AGE + sexgp +satisfaction + shiftWork + njob)\n\n각 모델이 잘 이루어졌는지 확인해 봅니다 . 로지스틱 회귀분서의 자세한 내용은 통계학 강의를 꼭 참고해 주세요!.\n\nsummary(mod1)\n\n\nCall:\nglm(formula = sleepgp == \"1.sleep disturbance\" ~ wwa1gp, family = \"binomial\", \n    data = .)\n\nDeviance Residuals: \n    Min       1Q   Median       3Q      Max  \n-0.8450  -0.4522  -0.3357  -0.3300   2.4238  \n\nCoefficients:\n                  Estimate Std. Error z value Pr(>|z|)    \n(Intercept)       -2.88303    0.03929 -73.378   <2e-16 ***\nwwa1gp1.Rarely     0.03526    0.05500   0.641    0.521    \nwwa1gp2.Sometimes  0.65426    0.05170  12.655   <2e-16 ***\nwwa1gp3.Often      1.31024    0.05681  23.062   <2e-16 ***\nwwa1gp4.Always     2.03679    0.08245  24.704   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 23305  on 41107  degrees of freedom\nResidual deviance: 22258  on 41103  degrees of freedom\nAIC: 22268\n\nNumber of Fisher Scoring iterations: 5\n\n\noddsf() 라는 함수로 결과를 확인해 보겠습니다 .\n\noddsf(mod1, mod2, mod3) %>% htmlTable()\n\n\n\n\n\nVariables\nValues\nModel.I\nModel.II\nModel.III\n\n\n\n\n1\nwwa1gp\n0.Never\n1.00 (reference)\n1.00 (reference)\n1.00 (reference)\n\n\n2\nwwa1gp\n1.Rarely\n1.04 (0.93-1.15)\n1.00 (0.90-1.12)\n1.01 (0.91-1.13)\n\n\n3\nwwa1gp\n2.Sometimes\n1.92 (1.74-2.13)\n1.83 (1.65-2.03)\n1.88 (1.69-2.08)\n\n\n4\nwwa1gp\n3.Often\n3.71 (3.32-4.14)\n3.42 (3.05-3.83)\n3.49 (3.11-3.91)\n\n\n5\nwwa1gp\n4.Always\n7.67 (6.52-9.01)\n6.91 (5.85-8.16)\n7.05 (5.96-8.33)\n\n\n6\nsexgp\nMen\n\n1.00 (reference)\n1.00 (reference)\n\n\n7\nsexgp\nWomen\n\n1.53 (1.42-1.65)\n1.54 (1.43-1.66)\n\n\n8\nAGE\n\n\n1.01 (1.01-1.02)\n1.01 (1.01-1.02)\n\n\n9\nsatisfaction\n\n\n2.29 (2.15-2.44)\n2.27 (2.13-2.42)\n\n\n10\nshiftWork\n0.non shift work\n\n\n1.00 (reference)\n\n\n11\nshiftWork\n1.shift work\n\n\n1.51 (1.32-1.72)\n\n\n12\nnjob\n0.one-job\n\n\n1.00 (reference)\n\n\n13\nnjob\n1.njob\n\n\n1.59 (1.15-2.19)\n\n\n\n\n\n예상한대로 결과가 나왔다면 oddsTabf()를 이용해서 복사 붙여 넣기를 하겠습니다.\n\noddsTabf(mod1, mod2, mod3)"
  }
]