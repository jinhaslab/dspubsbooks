[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "보건학데이터과학 실습",
    "section": "",
    "text": "소개"
  },
  {
    "objectID": "index.html#보건학",
    "href": "index.html#보건학",
    "title": "보건학데이터과학 실습",
    "section": "보건학",
    "text": "보건학\n보건학은 인간과 그들의 사회의 건강을 향상시키기 위한 과학입니다. 보건학은 의학에서 사회과학에 이르기까지 여러 학문과 밀접하게 연관되어 있습니다. 따라서, 다학제적 접근법은 보건학 전문가에게 가장 중요한 기술 중 하나입니다."
  },
  {
    "objectID": "index.html#보건학-데이터과학",
    "href": "index.html#보건학-데이터과학",
    "title": "보건학데이터과학 실습",
    "section": "보건학 데이터과학",
    "text": "보건학 데이터과학\n데이터 과학은 크게 데이터를 수집, 처리, 분석하고, 그 결과를 해석하여 의사결정이나 예측, 분류 등의 작업을 수행하는 분야입니다. 이를 위해 프로그래밍, 통계학, 머신러닝 및 도메인 지식을 종합적으로 활용합니다. 이러한 기술을 보건학에 접목시키는 것이 보건학 데이터과학입니다.\n보건학 데이터과학의 주요 특징은 다음과 같습니다:\n\n다양한 데이터의 수집 및 관리:\n\n보건학에서는 환자 기록, 임상 데이터, 역학 조사 데이터, 환경 데이터 등 다양한 유형의 데이터를 다룹니다. 이러한 데이터의 효율적인 수집과 관리는 보건학의 데이터과학에서 중요한 부분을 차지합니다.\n\n통계 및 머신러닝의 적용:\n\n공공보건의 문제를 해결하기 위해, 통계적 방법과 머신러닝 기술을 사용하여 데이터에서 통찰력을 얻거나 예측 모델을 만드는 작업을 수행합니다.\n\n데이터 시각화:\n\n복잡한 보건 데이터를 쉽게 이해하고 해석하기 위해 시각화 기술을 사용합니다. 이를 통해 정책 결정자나 일반 대중에게 데이터를 효과적으로 전달할 수 있습니다.\n\n재현성 및 공유 가능한 연구:\n\n보건학 데이터과학에서는 연구 결과의 재현성을 보장하고, 연구 결과를 다른 연구자와 공유할 수 있도록 투명한 방법을 추구합니다.\n\n도메인 지식:\n\n보건학 데이터과학자는 단순히 데이터과학의 기술만을 가지고 있는 것이 아니라, 보건학에 대한 깊은 이해도 필요합니다. 이를 통해 데이터를 올바르게 해석하고, 실제 보건 문제에 적절한 솔루션을 제시할 수 있습니다."
  },
  {
    "objectID": "index.html#보건학-데이터-과학-과학이-되려면",
    "href": "index.html#보건학-데이터-과학-과학이-되려면",
    "title": "보건학데이터과학 실습",
    "section": "보건학 데이터 과학, 과학이 되려면",
    "text": "보건학 데이터 과학, 과학이 되려면\n과학에서의 제현성 과학에서의 재현성은 연구 결과를 다른 연구자들이 동일한 조건 하에서 반복해서 얻을 수 있는지의 여부를 나타내는 중요한 원칙입니다. 재현성은 과학적 연구의 진정성과 신뢰성을 평가하는 기준 중 하나로 간주됩니다.\n보건학 데이터과학이 과학의 기준에 부합하려면 다음과 같은 재현성 요소들을 갖추어야 합니다\n\n데이터의 접근성:\n\n연구에 사용된 원본 데이터는 공개되어야 하며, 연구를 재현하려는 다른 연구자들이 접근할 수 있어야 합니다. 당연히 개인정보 보호와 관련된 법률 및 규정을 준수하면서, 필요한 경우 익명화 또는 변조된 형태로 데이터를 공개해야 합니다.\n\n분석 코드 및 소프트웨어의 공개:\n\n연구에 사용된 데이터 처리, 분석, 시각화 등의 코드와 사용된 소프트웨어의 버전 정보도 공개되어야 합니다.\n\n분석 방법론의 명확성:\n\n사용된 통계적 방법, 머신러닝 알고리즘, 모델링 접근법 등이 명확하게 기술되어야 합니다.\n\n외부 변수 및 제어:\n\n연구 과정에서 영향을 미칠 수 있는 외부 변수들에 대한 정보와 그것들을 어떻게 제어했는지에 대한 정보가 필요합니다.\n\n결과의 재현 가능성 평가:\n\n가능한 경우, 연구 결과의 재현 가능성을 평가하기 위해 독립된 데이터셋이나 방법론을 사용하여 검증을 시도해야 합니다.\n\n연구 환경의 명세:\n\n연구가 수행된 하드웨어 및 소프트웨어 환경, 그리고 이를 설정하기 위한 파라미터 등도 기록되어야 합니다. 이는 특히 계산적으로 복잡한 모델이나 시뮬레이션을 다룰 때 중요합니다.\n\n피어 리뷰:\n\n보건학 데이터과학 연구의 결과는 동료 평가 과정을 거쳐 검증되어야 합니다. 피어 리뷰는 연구의 품질과 재현성을 높이는 데 중요한 역할을 합니다.\n\n\n정리하면 아래와 같은 흐름데로 연구하게 됩니다.\n 이 튜토리얼에서는 R, Rstudio, markdown, Shiny server, PostgreSQL 및 github를 사용할 것입니다. R은 무료 오픈 소스 통계 언어로, 데이터 과학 분야에서 널리 사용됩니다. 가장 중요한 참고 자료는 Rafael A. Irizarry의 책과 Hadley Wickham의 책입니다. 아래와 같습니다."
  },
  {
    "objectID": "index.html#참고-books",
    "href": "index.html#참고-books",
    "title": "보건학데이터과학 실습",
    "section": "참고 books",
    "text": "참고 books\n\n\n\n\n\n\n\n\ntitle\nauthos\nurl\n\n\n\n\nIntroduction to Data Science with R\nRafael A. Irizarry\nhttps://rafalab.github.io/dsbook/\n\n\nR for Data Science\nGarrett Grolemund, Hadley Wickham\nhttps://r4ds.had.co.nz/index.html\n\n\n\n\nI hope you will get valuable experience with me.\n\n그럼 시작하겠습니다.!!! jinha"
  },
  {
    "objectID": "210_randrstudio.html#rstudio-cloud",
    "href": "210_randrstudio.html#rstudio-cloud",
    "title": "1  R & R studio 사용",
    "section": "1.1 Rstudio Cloud",
    "text": "1.1 Rstudio Cloud\nR studio cloud는 R과 R studio를 가장 빠르고 쉽게 사용할 수 있는 방법입니다. 다양한 옵션이 있으며, 무료 옵션도 포함되어 있습니다.\n\nRstudio cloud 로그인 방법\n\n RStudio Cloud  에 접속합니다.\n로그인을 합니다.\nNew Project 를 실행합니다.\n시작합니다.\n\n\n아래 동영상으로 되어 있으니 참고하시기 바랍니다."
  },
  {
    "objectID": "210_randrstudio.html#r-and-r-studio-on-window-system",
    "href": "210_randrstudio.html#r-and-r-studio-on-window-system",
    "title": "1  R & R studio 사용",
    "section": "1.2 R and R studio on Window system",
    "text": "1.2 R and R studio on Window system\n여기에서는 Windows 시스템에서 R과 R 스튜디오를 설치하는 방법을 설명합니다.\n\n구글에서 R cran을 검색하세요.\n\n\n아래와 같은 사이트가 나타날 것입니다.\n\n\nR을 다운로드 및 설치하기를 클릭하세요.\nWindows용 R 다운로드하기\nBase → Install R for the first Time\nDownload R * for Windows\n\n\n\n\nR설치\n\n\n\n1.2.1 R studio install\nR 스튜디오 설치는 정말 쉽습니다. Rstudio 로 검색한 다음 아래의 사이트에 들어갑니다. https://posit.co/download/rstudio-desktop/\n\n\n\nR 설치 사이트\n\n\n여기서 R studio 를 클릭해서 다운로드 후 설치하면 됩니다.\n\n\n1.2.2 R studio project\nR 스튜디오는 프로젝트 옵션을 제공합니다. 프로젝트는 데이터와 스크립트를 가져오고 내보내는 기본 경로를 만듭니다. 프로젝트를 공유할 때 협업이 쉬워집니다.\n\n\n저는 또한 흔히 사용되는 기본 디렉토리를 권장합니다. 이것은 동료와 아이디어를 공유하는 또 다른 규칙입니다.\n\n\n우리가 Windows 시스템을 사용하더라도 복사 및 이동과 같은 기본 명령은 코딩 프로세스를 용이하게 만드는 데 필요합니다. 아래 동영상을 보세요\n\n\n네, 이제 R 코딩을 시작할 준비가 되었습니다."
  },
  {
    "objectID": "210_randrstudio.html#r-and-r-studio-on-ubuntus",
    "href": "210_randrstudio.html#r-and-r-studio-on-ubuntus",
    "title": "1  R & R studio 사용",
    "section": "1.3 R and R studio on Ubuntus",
    "text": "1.3 R and R studio on Ubuntus\n우분투스 서버에 R을 설치하는 과정입니다. 아마존, 구글클라우드등 서버에 설치할때 아래의 동영상을 따라해 주세요. 필요한 분만 하시면 됩니다. 여러 복잡한 과정이 있으니, 아래의 구글 docs를 보고 따라해 주세요.\n참고 동영상 \nGoogle Doc   Google Doc Download"
  },
  {
    "objectID": "221_Rbasic1.html#vector-matirx-list",
    "href": "221_Rbasic1.html#vector-matirx-list",
    "title": "2  R 속성",
    "section": "2.1 vector matirx list",
    "text": "2.1 vector matirx list\n\n2.1.1 objects\n값(value)을 변수(variable)에 대입시키는 방법이다. 이를 이용해서 변수를 통한 연산이 가능하다.\n\na <-1\nb <-2\nc <- -1\n\na*b+c\n\n[1] 1\n\n\n값에는 숫자 외에도 여러 종류가 가능하다. 대표적인 것이 숫자(numeric), 문자(character), 논리값(logical) 값을 대입시킬 수 있다.\n\nstudent_a_age  <- 43\nstudent_a_name <- '윤진하'\nstudent_a_pass <- FALSE\n\n즉, 한변수에 하나의 값을 제공하는 0차원적 개념이다.\n\n\n2.1.2 백터 (Vectors), 팩터 (factors)\n백터는 한 변수에 여러개의 값이 존재하는 경우다. 이때 c() 를 사용하고 c는 concatenate의 C이다. 결측값 (missing value) 는 NA나 NAN으로 표시된다. 백터에는 순서가 존재하므로, my_vector[i] 를 이용하여 i번째 값을 추출할 수있다.\n\nstudent_all_age <- c(24, 31, 40, 16)\nstudent_all_age\n\n[1] 24 31 40 16\n\n\n각각 아래의 명령에 따라 어떤 값이 나타날지 예상해보자.\n\nstudent_all_age[1]\nstudent_all_age[1:2]\nstudent_all_age[c(1, 3)]\nstudent_all_age[-4]\n\n숫자로된 백터는 기본 함수를 사용하여 요약값을 나타낼 수 있다. max(), min(), range(), length(), sum(), mean(), prod(), sd(), var(), sort() 등이 있다.\n\nmax(student_all_age)\n\n[1] 40\n\nlength(student_all_age)\n\n[1] 4\n\nstudent_all_name <- c('영희', '철수', '은미', '재석')\nsummary(student_all_name)\n\n   Length     Class      Mode \n        4 character character \n\nstudent_all_class <- c('group1','group2', 'group1', 'group2' )\nsummary(student_all_class)\n\n   Length     Class      Mode \n        4 character character \n\n\n여기서 student_all_class 는 group이 1과2로 나뉘어 있는 것을 볼 수 있다. 이러한 개념은 팩터로 살펴볼 수 있다. 컴퓨터에게 sutdent_all_class가 팩터라는 것을 알려주자.\n\nstudent_all_group <-factor(c('group1','group2', 'group1', 'group2' ))\nsummary(student_all_group)\n\ngroup1 group2 \n     2      2 \n\n\ngroup이 있으니 몇가지 쉬운 이용방법이 생겼다.\n\ntapply(student_all_age, student_all_group, mean)\n\ngroup1 group2 \n  32.0   23.5 \n\n\n미리 이야기 하지만 *apply에 익수해져야한다. 이제, 1차원의 데이터 형식을 보았다. 메트릭스로 넘어 2차원의 자료를 살펴 보자\n\n\n2.1.3 매트릭스 (Matrix), 데이터프래임 (data frame), 리스트 (list)\n우리가 흔히 보았던 엑셀이나 표 형식의 데이터이다. 메트릭스는 행(row)와 열(column)로 구성되어 있고 백터 변수를 행을 기준으로 나열 할지, 열을 기준으로 할지 여부로 구성할 수 있다. 어떤 결과가 나오는지 확인해 보자.\n\nA1 = matrix( \n     c(1, 2, 3, 4, 5, 6, 7, 8),  # 값 \n     nrow=2,                     # 행 갯수\n     ncol=4,                     # 열 갯수\n     byrow = TRUE)               # 행을 기준으로 순서대로\nA1 # 출력\n\n그렇다면 똑 같이 1, 2, 3, 4, 5, 6, 7, 8를 이용해서 아래의 행렬을 만들어보자\n\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n[4,]    7    8\n\n\n행렬이 행(column)에 같은 성질의 값 들로 이루어져 있다면 데이터프래임은 좀더 자유롭다고 볼 수 있다.\n\ndspub_class <- data.frame(\n  'name'  = student_all_name, \n  'age'   = student_all_age,\n  'group' = student_all_group\n)\ndspub_class\n\n  name age  group\n1 영희  24 group1\n2 철수  31 group2\n3 은미  40 group1\n4 재석  16 group2\n\n\n데이터프래임 부터는 tidyverse 패키지를 사용해서 몇가지를 보겠다. %>%는 pipe로 앞에 있는 것을 가지도 뒤에 명령을 하자는 조사 같은 것으로 이해하자. mutate는 가로 안에 있는 명령을 수행해서 새로운 변수를 만들라는 것이다.\n\n#install.packages(\"tidyverse\")\nlibrary(tidyverse)\n\n\ndspub_class %>%\n  group_by(group) %>%\n  summarize(avg = mean(age))\n\n# A tibble: 2 × 2\n  group    avg\n  <fct>  <dbl>\n1 group1  32  \n2 group2  23.5\n\n\n과제가 있다. 과제는 DSpub내 group1 과 gropu2가 몇개인지와 최고 나이를 맞추는 것이다. 영희/철수에게 첫번째 숙제를, 은미/재석에게 두번째 숙제를 냈다. 과제를 받았다.\n\nhomework1 <- dspub_class %>%\n  group_by(group) %>%\n  mutate(avg_age = mean(age))\nhomework2 <- dspub_class %>%\n  group_by(group) %>%\n  mutate(max_age = max(age))\n\n\nhomework1\n\n# A tibble: 4 × 4\n# Groups:   group [2]\n  name    age group  avg_age\n  <chr> <dbl> <fct>    <dbl>\n1 영희     24 group1    32  \n2 철수     31 group2    23.5\n3 은미     40 group1    32  \n4 재석     16 group2    23.5\n\nhomework2\n\n# A tibble: 4 × 4\n# Groups:   group [2]\n  name    age group  max_age\n  <chr> <dbl> <fct>    <dbl>\n1 영희     24 group1      40\n2 철수     31 group2      31\n3 은미     40 group1      40\n4 재석     16 group2      31\n\n\n이것을 어딘가에 저장하고 싶다, 이때 list를 사용할 수 있다.\n\nsecond_week_dspub <-\n  list(\n       student_all_age,\n       student_all_class,\n       student_all_group,\n       student_all_name,\n       dspub_class, \n       homework1,\n       homework2\n       )\nsecond_week_dspub\n\n[[1]]\n[1] 24 31 40 16\n\n[[2]]\n[1] \"group1\" \"group2\" \"group1\" \"group2\"\n\n[[3]]\n[1] group1 group2 group1 group2\nLevels: group1 group2\n\n[[4]]\n[1] \"영희\" \"철수\" \"은미\" \"재석\"\n\n[[5]]\n  name age  group\n1 영희  24 group1\n2 철수  31 group2\n3 은미  40 group1\n4 재석  16 group2\n\n[[6]]\n# A tibble: 4 × 4\n# Groups:   group [2]\n  name    age group  avg_age\n  <chr> <dbl> <fct>    <dbl>\n1 영희     24 group1    32  \n2 철수     31 group2    23.5\n3 은미     40 group1    32  \n4 재석     16 group2    23.5\n\n[[7]]\n# A tibble: 4 × 4\n# Groups:   group [2]\n  name    age group  max_age\n  <chr> <dbl> <fct>    <dbl>\n1 영희     24 group1      40\n2 철수     31 group2      31\n3 은미     40 group1      40\n4 재석     16 group2      31\n\n\n숙제 과제만 뽑아 내서 보고 싶다면, 해당 list만 출력하면 된다. 즉 list에는 거의 모든 자료가 이질성을 갖고 있더라도 저장된다.\n\nsecond_week_dspub[[7]]\n\n# A tibble: 4 × 4\n# Groups:   group [2]\n  name    age group  max_age\n  <chr> <dbl> <fct>    <dbl>\n1 영희     24 group1      40\n2 철수     31 group2      31\n3 은미     40 group1      40\n4 재석     16 group2      31"
  },
  {
    "objectID": "221_Rbasic1.html#기초-연산",
    "href": "221_Rbasic1.html#기초-연산",
    "title": "2  R 속성",
    "section": "2.2 기초 연산",
    "text": "2.2 기초 연산\n단순 계산기로 사용할 수 있다. 예를 들어 1+2 의 값이라던가, log2(10) 등을 계산할 수 있다. Rsutdio 의 스크립트 창이나 콘솔 창에 아래의 항목을 작성해 볼 수 있다.\n\n3+4;4-3;4/3;3*4\nlog2(10)\nabs(-4)\nsqrt(4)\n\n기초 함수는 아래와 같다.\n\n\n\nOperator\nDescription\n\n\n\n\n+\naddition\n\n\n-\nsubtraction\n\n\n*\nmultiplication\n\n\n/\ndivision\n\n\n^ or **\nexponentiation\n\n\nx %% y\nmodulus (x mod y) 5%%2 is 1\n\n\nx %/% y\ninteger division 5%/%2 is 2\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n<\nless than\n\n\n<=\nless than or equal to\n\n\n>\ngreater than\n\n\n>=\ngreater than or equal to\n\n\n==\nexactly equal to\n\n\n!=\nnot equal to\n\n\n!x\nNot x\n\n\nx\ny\n\n\nx & y\nx AND y\n\n\nisTRUE(x)\ntest if X is TRUE\n\n\n\n\n\n\n\n\n\n\nOperator\nDescription\n\n\n\n\nLogarithms and exponentials\nlog2(x), log10(x), exp(x)\n\n\nTrigonometric functions\ncos(x), sin(x), tan(x), acos(x), asin(x), atan(x)\n\n\nOthers\nabs(x): absolute value; sqrt(x): square root.\n\n\n\n기초 함수 중에 몇몇은 그림을 그려보아야 이해가 쉽다.\n\npm10 = rnorm(n=100, mean = 10, sd = 5) # 평균이 10이고 표준편차가 5인 100개의 랜덤 변수를 pm10 이라고 가정하자\ndate= rep(1:100)  # 1일부터 100까지의 시간이 있다고 해보자\nplot(x=date, y=pm10, type = \"l\") # \"l\" line 형식으로 그려보았다. \n\n\n\noz = sin(date) # 오존은 시간에 따라 햇빛이 있을 때 높게 올라간다. sine 함수를 따른다고 가정해 보자\nplot(x=date, y = oz, type = \"l\") # \n\n\n\noz2 = oz**2 # -값을 갖는 것은 좀 이상하다. 제곱을 통해 변경해 보자\nplot(x=date, y = oz2, type = \"l\") # \n\n\n\nozabs = abs(oz) # 접곱보다 절대 값이 어떨까?\nplot(x=date, y = ozabs, type = \"l\") # \n\n\n\npmtrend = pm10 + date  # 시간에 따라 pm10 농도가 올라간다고 가정해 보자\nplot(x=date, y = pmtrend, type=\"l\")\n\n\n\npmtrend.log = log(pmtrend) # 로그 값을 넣어보자. 특별한 의미는 없이 함수에 대한 실습이다. \nplot(x=date, y = pmtrend.log, type=\"l\") #"
  },
  {
    "objectID": "221_Rbasic1.html#조건부-연산",
    "href": "221_Rbasic1.html#조건부-연산",
    "title": "2  R 속성",
    "section": "2.3 조건부 연산",
    "text": "2.3 조건부 연산\nif-else 라는 조건에 따라 연산을 수행시킨다. 예를 들어 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 의 백터에서 5보다 작으면 A 크면 B를 적용시켜주다.\n\nnums<- 1\nif (nums <5) {\n        chars = 'A'\n} else{\n        chars = 'B'\n}\nchars\n\n[1] \"A\"\n\n\n\nnums <- 6\nif (nums <5) {\n        chars = 'A'\n} else{\n        chars = 'B'\n}\nchars\n\n[1] \"B\"\n\n\n몇가지 예제를 더 살펴보자.\n\na<-round(rnorm(10)*10)\na\n\n [1] -2 19  3 14  6 10  6  7  3 19\n\ntab <- ifelse(a>0, '양수', '음수')\ntab\n\n [1] \"음수\" \"양수\" \"양수\" \"양수\" \"양수\" \"양수\" \"양수\" \"양수\" \"양수\" \"양수\"\n\ndata.frame(a, tab)\n\n    a  tab\n1  -2 음수\n2  19 양수\n3   3 양수\n4  14 양수\n5   6 양수\n6  10 양수\n7   6 양수\n8   7 양수\n9   3 양수\n10 19 양수\n\n\n데이터 클리닝에서 자주 사용하는 두개의 조건문 any()와 all()이 있다. any()는 하나라도 TRUE값이 있으면 TRUE를 변환해주고, all()은 모두 TRUE여야 TRUE를 돌려준다.\n\nnew.var <- c(1, 2, NA)\nis.na(new.var)\n\n[1] FALSE FALSE  TRUE\n\nany(is.na(new.var))\n\n[1] TRUE\n\nall(is.na(new.var))\n\n[1] FALSE\n\n\nindex 를 이용하면 조건 문에서 IF (또는 Where)의 개념을 사용할 수 있다. iris 데이터에서 Sepal.Length 가 가장 큰 값은 찾고, Sepal.Length 최고 값을 갖은 Species의 종류를 찾고자한다. 어떻게 하면될까?\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\ntable(iris$Species)\n\n\n    setosa versicolor  virginica \n        50         50         50 \n\nmax(iris$Sepal.Length)\n\n[1] 7.9\n\nmax.length <- which.max(iris$Sepal.Length)\niris$Species[max.length]\n\n[1] virginica\nLevels: setosa versicolor virginica\n\n\n같은 방법으로 iris 데이터에서 Sepal.Length 가 가장 작은 찾고, Sepal.Length 최소 값을 갖은 Species의 종류를 찾고자한다. 최소 값과 종류를 쏘보자\n\nmin(iris$Sepal.Length)\n\n[1] 4.3\n\nmin.length <- which.min(iris$Sepal.Length)\niris$Species[min.length]\n\n[1] setosa\nLevels: setosa versicolor virginica"
  },
  {
    "objectID": "221_Rbasic1.html#함수-만들기",
    "href": "221_Rbasic1.html#함수-만들기",
    "title": "2  R 속성",
    "section": "2.4 함수 만들기",
    "text": "2.4 함수 만들기\nR을 이용하는 이유중 하나가 함수를 손쉽게 만들고 그 결과를 활용하기가 쉽다는 것이다. 자동문, 반복문, 데이터 클리능, 데이터 시각화 등에서 자주 사용하는 기본 원리이다. 숫자 2개를 넣으면 덧 샘을 해주는 함수를 만들어 보자\n\naddtive.function = function(x, y ){\n  x + y\n}\n\n\naddtive.function(100, 2)\n\n[1] 102\n\n\n\n퀴즈\n\n숫자 2개를 넣으면 두 수의 차이를 보여주는 함수를 만들어 보자 abs 사용. #-#에 계산식을 넣어 함수를 완성해 보세요.\n\nabs.function= function(x, y ){\n  #--#\n}\n\n평균을 구해주는 함수 avg를 만들어 보자. length는 길이를 말해주니, 몇개의 변수값이 있는 지 알 수 있다.\n\nmy_vector<- 1:50\navg <- function(x){\n        sum(x)/length(x)\n}\navg(my_vector)\n\n[1] 25.5\n\n\n좀더 확장해서 변수 갯수, 평균, 최고, 최저 값을 나타내는 함수를 만들어 보자.\n\ntabs <- function(x){\n        data.frame( '평균'      = mean(x), \n                    '변수갯수'  = length(x), \n                    '최고값'    = max(x), \n                    '최저값'    = min(x)\n        )\n}\n\ntabs(my_vector)\n\n  평균 변수갯수 최고값 최저값\n1 25.5       50     50      1\n\n\n그럼 이를 이용해서, 다음을 해석해 보자\n\navg <- function(x, arithmetic = TRUE){\n  n <- length(x)\n  ifelse(arithmetic, sum(x)/n, prod(x)^(1/n))\n}"
  },
  {
    "objectID": "221_Rbasic1.html#반복문-vectorization-functionals",
    "href": "221_Rbasic1.html#반복문-vectorization-functionals",
    "title": "2  R 속성",
    "section": "2.5 반복문, vectorization, functionals",
    "text": "2.5 반복문, vectorization, functionals\n\n2.5.1 for loop\n1a, 2a, 3a, 4a, 5a, 6a, 7a, 8a, 9a, 10a 을 만들어보자, 어떻게 하면될까?\n\nc('1a', '2a', '10a') # 이렇게 해보는 것도 좋지만\n\n[1] \"1a\"  \"2a\"  \"10a\"\n\n\n반목문을 사용하면, 아래와 같다.\n\nfor (i in 1:10){\n  print(paste0(i, 'a'))\n}\n\n[1] \"1a\"\n[1] \"2a\"\n[1] \"3a\"\n[1] \"4a\"\n[1] \"5a\"\n[1] \"6a\"\n[1] \"7a\"\n[1] \"8a\"\n[1] \"9a\"\n[1] \"10a\"\n\n\n물론 대부분 이렇게 사용하지만, 아래와 같이 사용한다.\n\npaste0(1:10, \"a\")\n\n [1] \"1a\"  \"2a\"  \"3a\"  \"4a\"  \"5a\"  \"6a\"  \"7a\"  \"8a\"  \"9a\"  \"10a\"\n\n\n1:n까지의 숫자 합을 만들어보자, 그리고 이를 1부터 100일때 까지 만들고 그림을 그려보자\n\ncompute <- function(n){ sum(1:n)}\ncompute(10)\n\n[1] 55\n\ntest <-c()\nfor (n in 1:100){\n  test[n] <- compute(n)\n}\n\nplot(1:100, test)\n\n\n\n\n\n\n2.5.2 vectorization 과 apply 구문\n사실 ifelse 를 잘 사용하지 않는다. 이는 속도의 문제와도 관련된다. 실제 ifesel 로 10분이 걸리는 연산이 1분으로 줄수도 있다. 이때 사용하게 되는 것이 백터화와 apply 구문이다. 이미 past0(1:10,“a”) 같은 구문이 편할 수 있다는 것을 느꼈을 것이다. 이번에는 구구단 2단과 3단을 서로 곱해보자. 어떻게 하면 좋을까 for와 if를 생각하기 보다 아래를 고려해 보자. 아래가 백터화이다.\n\nn2 <- c(1:9*2)\nn3 <- c(1:9*3)\nn2*n3\n\n[1]   6  24  54  96 150 216 294 384 486\n\n\n2단에 3단이 아닌 다른 단을 곱하는 함수를 사용해 보자\n\nnew.function<-function(n2){\n  c(1:9*2) * c(1:9*n2)\n}\n\nnew.function( 4)\n\n[1]   8  32  72 128 200 288 392 512 648\n\n\n그럼 3단 대신에 1, 2, 3, 4, 5, 6, 7, 8, 9 단을 모두 해보자\n\nsapply(1:9, new.function)\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n [1,]    2    4    6    8   10   12   14   16   18\n [2,]    8   16   24   32   40   48   56   64   72\n [3,]   18   36   54   72   90  108  126  144  162\n [4,]   32   64   96  128  160  192  224  256  288\n [5,]   50  100  150  200  250  300  350  400  450\n [6,]   72  144  216  288  360  432  504  576  648\n [7,]   98  196  294  392  490  588  686  784  882\n [8,]  128  256  384  512  640  768  896 1024 1152\n [9,]  162  324  486  648  810  972 1134 1296 1458\n\n\n상기 행렬을 만들기위해 ifelse를 사용하거나 for 문을 사용하면 좀더 머리가 복잡해 질 수 있다. apply 구문은 확실히 머리가 가벼워진다. tidyverse 부분을 할 때 apply, lapply, sapply등을 다루게 될 것이다."
  },
  {
    "objectID": "221_Rbasic1.html#iris-data-와-apply-구문",
    "href": "221_Rbasic1.html#iris-data-와-apply-구문",
    "title": "2  R 속성",
    "section": "2.6 iris data 와 apply 구문",
    "text": "2.6 iris data 와 apply 구문\nR을 여러 데이터를 이미 내장하고 있습니다. 이를 통해 여러 통계와 기계학습 등을 연습할 수 있도록 돕고 있습니다. 그 중 가장 유명한 자료인 iris 데이터를 불러오겠습니다.\n\ndata(\"iris\")\n\niris 데이터셋은 아이리스 꽃에 대한 측정값을 포함하고 있습니다. 이 데이터셋에는 3개의 다른 아이리스 꽃 종류에 대한 총 150개의 샘플이 있습니다. 데이터의 구조는 다음과 같습니다:\n\nSepal.Length (꽃받침 길이)\nSepal.Width (꽃받침 너비)\nPetal.Length (꽃잎 길이)\nPetal.Width (꽃잎 너비)\nSpecies (종): 아이리스 꽃의 종류를 나타냅니다.\n\n이 데이터셋에는 ‘setosa’(세토사), ‘versicolor’(버시컬러), ‘virginica’(버지니카)라는 3개의 종류가 있습니다.\n\n\n\nlibrary(tidyverse)\niris %>% head()\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\nSpecies 는 종에 대한 이야기이고, 이것은 문자로 구성되어 있습니다. 나머지는 모두 숫자로 되어 있습니다. 숫자로 되어 있는 변수들에서 평균, 중간, 표준편차를 구해보겠습니다.\n이 예제를 통해 apply 구문이 어떻게 사용되는지 알아보겠습니다. 우선 apply구문을 사용하지 않고 구해보겠습니다.\n\niris_num=iris[, c(1:4)] # Species 를 제외한 나머지 변수만 선정\niris_num=iris %>% select(1:4) # tidyverse를 통해 같은 결과 사용\n# 아래와 같인 평균, sd 를 구했습니다.\niris_num %>% pull(Sepal.Length) %>% mean()\n\n[1] 5.843333\n\niris_num %>% pull(Sepal.Width)  %>% mean()\n\n[1] 3.057333\n\niris_num %>% pull(Petal.Length) %>% mean()\n\n[1] 3.758\n\niris_num %>% pull(Petal.Width)  %>% mean()\n\n[1] 1.199333\n\niris_num %>% pull(Sepal.Length) %>% sd()\n\n[1] 0.8280661\n\niris_num %>% pull(Sepal.Width)  %>% sd()\n\n[1] 0.4358663\n\niris_num %>% pull(Petal.Length) %>% sd()\n\n[1] 1.765298\n\niris_num %>% pull(Petal.Width)  %>% sd()\n\n[1] 0.7622377\n\n\n같은 방식으로 median 도 구할 수 있겠습니다. 그런데, 무언가 반복되는 느낌이 듭니다. 코드를 만들때 반복된다면, 동일한 논리가 반복된다면 함수를 사용할 수 있습니다. 이때 apply 구문을 이용해 보겠습니다. apply는 결과를 백터로, lapply는 결과를 list로 반환해 줍니다. sapply는 lapply 값을 보기 좋게 만들어 줍니다.\n\napply(iris_num, 2, mean)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n    5.843333     3.057333     3.758000     1.199333 \n\nlapply(iris_num, mean)\n\n$Sepal.Length\n[1] 5.843333\n\n$Sepal.Width\n[1] 3.057333\n\n$Petal.Length\n[1] 3.758\n\n$Petal.Width\n[1] 1.199333\n\nsapply(iris_num, mean)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n    5.843333     3.057333     3.758000     1.199333 \n\n\n그렇다면 이제는 평균, 중간값, 표준편차 모두를 구해보겠습니다. 반복되는 것이니 함수를 만들겠습니다. stat_smry는\n\nstat_smry = function(x){\n  list(\n    mean  =mean(x), \n    median=median(x), \n    std   = sd(x)\n  )\n}\n\n이제 sapply를 이용하여 작업해 보겠습니다.\n\nsapply(iris_num, stat_smry)\n\n       Sepal.Length Sepal.Width Petal.Length Petal.Width\nmean   5.843333     3.057333    3.758        1.199333   \nmedian 5.8          3           4.35         1.3        \nstd    0.8280661    0.4358663   1.765298     0.7622377  \n\n\n개인적으로 저는 lapply를 사용합니다. 그 이유는 단계별 확인 후 합치는 것이 데이터를 분석할 때 유리한 점이 있기 때문입니다. 단계별 확인이란 반복하는 데이터 별로 어디에 문제가 있는지 확인하는 과정이 데이터가 커질 수록 꼭 필요하기 때문입니다. 아래는 lapply로 tt라는 list를 만들고 확인한 후 do.call(rbidn, .) 모두 합치는 방식입니다 .rbind 는 row bind 로 list 안에 있는 백터, 데이터프레임 등을 누적해서 합쳐서 하나의 파일로 만드는 것입니다. 복잡하지요, 이해보다는 익숙해 지는 순간이 온 것입니다.\n\ntt = lapply(iris_num, stat_smry)\n\n\nnames(tt) # 각 반복된 요인 이름\n\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\" \n\ntt[[1]]   # 첫번째 여기서는 \"Sepal.Length\"에대한 값\n\n$mean\n[1] 5.843333\n\n$median\n[1] 5.8\n\n$std\n[1] 0.8280661\n\ndo.call(rbind, tt) # 정리된 모양\n\n             mean     median std      \nSepal.Length 5.843333 5.8    0.8280661\nSepal.Width  3.057333 3      0.4358663\nPetal.Length 3.758    4.35   1.765298 \nPetal.Width  1.199333 1.3    0.7622377"
  },
  {
    "objectID": "231_dataimportsave.html#데이터-업로드",
    "href": "231_dataimportsave.html#데이터-업로드",
    "title": "3  데이터 불러오기",
    "section": "3.1 데이터 업로드",
    "text": "3.1 데이터 업로드\n데이터를 불러오는 방법과 저장하는 방법에 대해서 이야기 하겠습니다.\n\n로칼 데이터 불러오기\n\n우선 rstudio 에서 upload 버튼을 사용하는 것입니다. 우측 아래에 있습니다. 여기서 화살표 위로되어 있는 버튼이 업로드 버튼입니다.\n\n\n\n업로드버튼\n\n\n업로드 버튼을 눌러서, 파일을 업로드 하는 방식입니다. 가장 많이 사용하는 방식입니다.\n\n웹이 있는 데이터 불러오기\n\n웹에 있는 데이터가 링크가 있다면 다운로드 받는 방법입니다. download.file 이란 함수를 쓰고, 주소와 저장 장소 및 저장이름을 적어 주는 거입니다.\n\ndownload.file(\"https://raw.githubusercontent.com/jinhaslab/opendata/main/kwcs/kwcsData6th.rds\", \"data/kwcsData6th.rds\")\n\n이 자료를 불러오겠습니다.\n\nkwcs = readRDS(\"data/kwcsData6th.rds\")\n#head(kwcs)\n\n사용설명서도 다운로드 받겠습니다.\n\ndownload.file(\"https://raw.githubusercontent.com/jinhaslab/opendata/main/kwcs/pdf3.pdf\", \"data/kwcs6thkorea.pdf\")"
  },
  {
    "objectID": "231_dataimportsave.html#데이터-불러오기",
    "href": "231_dataimportsave.html#데이터-불러오기",
    "title": "3  데이터 불러오기",
    "section": "3.2 데이터 불러오기",
    "text": "3.2 데이터 불러오기\n\n3.2.1 CSV 파일\nread.csv, write.csv 를 이용합니다. iris 데이터를 이용해서 실습하겠습니다.\n\ndata(iris)\nwrite.csv(iris, \"data/iris.csv\")\niris_import = read.csv(\"data/iris.csv\")\n\ndata(iris) 이 부분은 R의 내장 데이터셋인 iris를 로드합니다. iris 데이터셋은 150개의 관측값과 5개의 변수 (꽃받침의 길이, 꽃받침의 너비, 꽃잎의 길이, 꽃잎의 너비, 종류)로 구성되어 있습니다. write.csv(iris, \"data/iris.csv\") 이 부분은 iris 데이터셋을 CSV 파일 형태로 저장합니다. 여기서 “data/iris.csv”는 파일의 경로와 이름을 나타냅니다. 해당 코드는 현재 작업 중인 디렉토리의 data 폴더 내에 iris.csv라는 이름으로 파일을 저장하려고 시도합니다. 만약 data 폴더가 존재하지 않으면 오류가 발생할 수 있습니다. write.csv 함수는 기본적으로 행 이름도 CSV 파일에 저장합니다. 따라서 CSV 파일에는 추가적으로 행 번호가 포함됩니다. iris_import = read.csv(\"data/iris.csv\") 이 부분은 방금 저장한 iris.csv 파일을 다시 R로 읽어들여 iris_import 변수에 저장합니다. read.csv 함수는 기본적으로 첫 번째 행을 변수명으로 간주합니다. 이 때, 위에서 언급했던 추가적으로 저장된 행 번호는 첫 번째 열로 읽히게 됩니다. 이 열의 이름은 일반적으로 X로 지정됩니다. 요약하면, 이 코드는 R의 iris 데이터셋을 CSV 파일로 저장한 다음, 그 파일을 다시 R로 읽어들이는 과정을 보여줍니다.\n\n\n3.2.2 excel 파일\n\niris 파일 excel로 저장\n\n먼저, Excel 파일로 저장하기 위해 writexl 패키지가 필요합니다. 그리고 xlsx 파일을 불러오기 위해서는 readxl 패키지가 필요합니다. install.packages를 이용하여 패키지를 설치합니다.\n\ninstall.packages(\"writexl\")\ninstall.packages(\"readxl\")\n\n\nlibrary(writexl)\nlibrary(readxl)\n\niris 데이터셋을 Excel 파일로 저장합니다. 이때 write_xlsx를 이용하고, 저장하고자 하는 데이터, 그리고 저장될 이름을 경로와 함께 저장합니다. write_xlsx 함수는 writexl 패키지에 포함된 함수로, 첫 번째 인수로 받은 데이터 프레임(iris)을 두 번째 인수로 받은 경로(“data/iris_saved.xlsx”)에 Excel 파일로 저장합니다.\n\n# iris 데이터셋을 Excel 파일로 저장\nwrite_xlsx(iris, \"data/iris_saved.xlsx\")\n\n\niris_xlsx <- readxl::read_xlsx(\"data/iris_saved.xlsx\")\n\nreadxl::read_xlsx(\"iris_saved.xlsx\"), read_xlsx 함수는 readxl 패키지에 있는 함수로, 인수로 받은 경로의 Excel 파일을 R의 데이터 프레임으로 불러옵니다. rreadxl::: readxl 패키지의 read_xlsx 함수를 호출하기 위해 패키지 이름과 함께 사용되는 방식입니다. 이렇게 하면 해당 패키지를 라이브러리로 로드하지 않고도 패키지의 함수를 사용할 수 있습니다.\n“data/iris_saved.xlsx”: 불러올 Excel 파일의 경로입니다. iris_xlsx: 위 코드에서 불러온 데이터를 저장하는 변수입니다. 불러온 데이터는 이 변수에 저장되므로 후에 iris_xlsx를 사용하여 데이터를 조회하거나 처리할 수 있습니다.\n\n\n3.2.3 stata, sas, spss 파일\nhaven 패키지는 주로 SPSS, Stata, SAS와 같은 다른 통계 소프트웨어에서 사용되는 파일 형식을 R에서 읽고 쓰기 위해 사용됩니다. 이번에는 iris 데이터셋과 haven 패키지를 함께 사용하여, 데이터셋을 이러한 형식으로 저장하고 다시 불러오는 실습을 하겠습니다.\n\ninstall.packages(\"haven\")\n\n\nlibrary(haven)\n\n\nSTATA.dta\n\n\nhaven::write_dta(iris, \"data/iris_stata.dta\")\n\n아마 error 메세지가 위에 처럼 발생할 것입니다. 이는 stata에서 사용하는 데이터 형식에에는 변수명에 .이 있는 경우 error를 발생시킬 수도 있기 때문입니다. 나중에 실습하겠지만, 변수 이름을 바꾸는 과정을 통해 . 을 _로 바꾸어 보겠습니다. 즉 현재는 변수 이름이 Sepal.Length 처럼 되어 있는 것을 Sepal_Length로 변경하는 것입니다. gsub을 이용할 것입니다.\n\nnames(iris) <- gsub(\"\\\\.\", \"_\", names(iris))\nwrite_dta(iris, \"data/iris_saved.dta\")\n\n이후 data 폴더로 가서 외부 반출을 한 다음 stata에서 열어 보면 되겠습니다.\n\n \n\n\nSPASS.sav\n\n\n# iris 데이터셋을 SPSS 파일로 저장\nwrite_sav(iris, \"data/iris_spss.sav\")\n\n\n# 저장한 SPSS 파일을 데이터 프레임으로 불러오기\niris_from_spss <- read_sav(\"data/iris_spss.sav\")\n\nwrite_sav: haven 패키지의 함수로, R의 데이터 프레임을 SPSS .sav 형식으로 저장합니다. read_sav: SPSS .sav 형식의 파일을 R의 데이터 프레임으로 불러옵니다.\n\nSAS, sas7bdat\n\n\n# iris 데이터셋을 SAS 파일로 저장\nwrite_sas(iris, \"data/iris_sas.sas7bdat\")\n\nWarning: `write_sas()` was deprecated in haven 2.5.2.\nℹ Please use `write_xpt()` instead.\n\n\n\n# 저장한 SAS 파일을 데이터 프레임으로 불러오기\niris_from_sas <- read_sas(\"data/iris_sas.sas7bdat\")"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  }
]